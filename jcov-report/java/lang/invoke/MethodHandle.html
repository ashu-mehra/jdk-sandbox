<!DOCTYPE html>
<html>
<head>
<title>tests coverage</title>
<link rel ="stylesheet" type="text/css" href="../../../style.css" title="Style">
<script type="text/javascript" src="../../../sorttable.js"></script>
<script type="text/javascript">
  targetPage = "" + window.location.search;
  if (targetPage != "" && targetPage != "undefined")
    targetPage = targetPage.substring(1);
  if (targetPage.indexOf(":") != -1 || (targetPage != "" && !validURL(targetPage)))
    targetPage = "undefined";
  function validURL(url) {
    var pos = url.indexOf(".html");
    if (pos == -1 || pos != url.length - 5)
      return false;
    var allowNumber = false;
    var allowSep = false;
    var seenDot = false;
    for (var i = 0; i < url.length - 5; i++) {
      var ch = url.charAt(i);
      if ('a' <= ch && ch <= 'z' ||
          'A' <= ch && ch <= 'Z' ||
          ch == '$' ||
          ch == '_') {
            allowNumber = true;
            allowSep = true;
      } else if ('0' <= ch && ch <= '9' ||
                 ch == '-') {
                   if (!allowNumber)
                     return false;
      } else if (ch == '/' || ch == '.') {
        if (!allowSep)
          return false;
        allowNumber = false;
        allowSep = false;
        if (ch == '.')
          seenDot = true;
        if (ch == '/' && seenDot)
          return false;
      } else {
        return false;
      }
    }
    return true;
  }
  function loadFrames() {
    if (targetPage != "" && targetPage != "undefined")
      top.classFrame.location = top.targetPage;
  }
</script>
</head>
<body>
<table>
<tr>
<td>
<a href="../../../index.html?java/lang/invoke/MethodHandle.html" target="_top">Frames</a>
<a href="MethodHandle.html" target="_top">No Frames</a>
</td>
</tr>
</table>
<br>
 <table cellspacing="0" cellpadding="0"class="report">
 <tr class="report">
 <th class="report">&nbsp;</th>
 <th class="report">%method</th>
 <th class="report">%block</th>
 <th class="report">%branch</th>
 <th class="report">%line</th>
 </tr>
 <tr class="report">
 <td class="reportText"><span class="text"> <b>java.lang.invoke.MethodHandle</b></span></td>
 <td class="reportValue"><table cellpadding="0" cellspacing="0" style="margin: 0 auto;"><tr><td><span class="text"><b>66</b>%(37/56)</span></td><tr><td><table class="percentGraph" cellpadding="0" cellspacing="0"><tr><td class="percentCovered" width="  66"></td><td class="percentUnCovered" width="34"></td></tr></table></td></tr></table></td>
 <td class="reportValue"><table cellpadding="0" cellspacing="0" style="margin: 0 auto;"><tr><td><span class="text"><b>55</b>%(112/202)</span></td><tr><td><table class="percentGraph" cellpadding="0" cellspacing="0"><tr><td class="percentCovered" width="  55"></td><td class="percentUnCovered" width="45"></td></tr></table></td></tr></table></td>
 <td class="reportValue"><table cellpadding="0" cellspacing="0" style="margin: 0 auto;"><tr><td><span class="text"><b>46</b>%(72/154)</span></td><tr><td><table class="percentGraph" cellpadding="0" cellspacing="0"><tr><td class="percentCovered" width="  46"></td><td class="percentUnCovered" width="54"></td></tr></table></td></tr></table></td>
 <td class="reportValue"><table cellpadding="0" cellspacing="0" style="margin: 0 auto;"><tr><td><span class="text"><b>63</b>%(128/203)</span></td><tr><td><table class="percentGraph" cellpadding="0" cellspacing="0"><tr><td class="percentCovered" width="  63"></td><td class="percentUnCovered" width="37"></td></tr></table></td></tr></table></td>
 </tr>
 </table>
 <br>
 <br>
 <table cellspacing="0" cellpadding="0"class="report" id="mcoverage">
 <tr class="report">
 <th class="report">hit count</th>
 <th class="report">method  name</th>
 <th class="report">method modifiers</th>
 <th class="report">method signature</th>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">64</span></td>
 <td class="reportText"><span class="text"><a href="#src_443">&lt;clinit&gt;</a></span></td>
 <td class="reportText"><span class="text">[static]</span></td>
 <td class="reportText"><span class="text">void &lt;clinit&gt;()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">101565132</span></td>
 <td class="reportText"><span class="text"><a href="#src_478">&lt;init&gt;</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">void &lt;init&gt;(java.lang.invoke.MethodType,java.lang.invoke.LambdaForm)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">81</span></td>
 <td class="reportText"><span class="text"><a href="#src_1284">asCollector</a></span></td>
 <td class="reportText"><span class="text">[public]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MethodHandle asCollector(java.lang.Class,int)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">81</span></td>
 <td class="reportText"><span class="text"><a href="#src_1331">asCollector</a></span></td>
 <td class="reportText"><span class="text">[public]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MethodHandle asCollector(int,java.lang.Class,int)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">400</span></td>
 <td class="reportText"><span class="text"><a href="#src_1345">asCollectorChecks</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">boolean asCollectorChecks(java.lang.Class,int,int)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">20282643</span></td>
 <td class="reportText"><span class="text"><a href="#src_1583">asFixedArity</a></span></td>
 <td class="reportText"><span class="text">[public]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MethodHandle asFixedArity()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">8</span></td>
 <td class="reportText"><span class="text"><a href="#src_1069">asSpreader</a></span></td>
 <td class="reportText"><span class="text">[public]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MethodHandle asSpreader(java.lang.Class,int)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">8</span></td>
 <td class="reportText"><span class="text"><a href="#src_1112">asSpreader</a></span></td>
 <td class="reportText"><span class="text">[public]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MethodHandle asSpreader(int,java.lang.Class,int)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">8</span></td>
 <td class="reportText"><span class="text"><a href="#src_1125">asSpreaderChecks</a></span></td>
 <td class="reportText"><span class="text">[private]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MethodType asSpreaderChecks(java.lang.Class,int,int)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">20296161</span></td>
 <td class="reportText"><span class="text"><a href="#src_862">asType</a></span></td>
 <td class="reportText"><span class="text">[public, final]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MethodHandle asType(java.lang.invoke.MethodType)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">20295866</span></td>
 <td class="reportText"><span class="text"><a href="#src_874">asTypeCached</a></span></td>
 <td class="reportText"><span class="text">[private]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MethodHandle asTypeCached(java.lang.invoke.MethodType)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">20295575</span></td>
 <td class="reportText"><span class="text"><a href="#src_902">asTypeUncached</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MethodHandle asTypeUncached(java.lang.invoke.MethodType)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">319</span></td>
 <td class="reportText"><span class="text"><a href="#src_1512">asVarargsCollector</a></span></td>
 <td class="reportText"><span class="text">[public]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MethodHandle asVarargsCollector(java.lang.Class)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">20287843</span></td>
 <td class="reportText"><span class="text"><a href="#src_1703">bindArgumentL</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.BoundMethodHandle bindArgumentL(int,java.lang.Object)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">20287843</span></td>
 <td class="reportText"><span class="text"><a href="#src_1618">bindTo</a></span></td>
 <td class="reportText"><span class="text">[public]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MethodHandle bindTo(java.lang.Object)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">64</span></td>
 <td class="reportText"><span class="text"><a href="#src_1828">customize</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">void customize()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_1693">debugString</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">java.lang.String debugString()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_1638">describeConstable</a></span></td>
 <td class="reportText"><span class="text">[public]</span></td>
 <td class="reportText"><span class="text">java.util.Optional describeConstable()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">20295656</span></td>
 <td class="reportText"><span class="text"><a href="#src_922">getApproximateCommonClassLoader</a></span></td>
 <td class="reportText"><span class="text">[private, static]</span></td>
 <td class="reportText"><span class="text">java.lang.ClassLoader getApproximateCommonClassLoader(java.lang.invoke.MethodType)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_1750">internalCallerClass</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">java.lang.Class internalCallerClass()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">7044</span></td>
 <td class="reportText"><span class="text"><a href="#src_1740">internalForm</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.LambdaForm internalForm()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">2</span></td>
 <td class="reportText"><span class="text"><a href="#src_1745">internalMemberName</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MemberName internalMemberName()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_1797">internalProperties</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">java.lang.Object internalProperties()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_1791">internalValues</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">java.lang.Object internalValues()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_1761">intrinsicData</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">java.lang.Object intrinsicData()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">6639</span></td>
 <td class="reportText"><span class="text"><a href="#src_1756">intrinsicName</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MethodHandleImpl$Intrinsic intrinsicName()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_0">invoke</a></span></td>
 <td class="reportText"><span class="text">[public, final, varargs, native]</span></td>
 <td class="reportText"><span class="text">java.lang.Object invoke(java.lang.Object[])</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_0">invokeBasic</a></span></td>
 <td class="reportText"><span class="text">[final, varargs, native]</span></td>
 <td class="reportText"><span class="text">java.lang.Object invokeBasic(java.lang.Object[])</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_0">invokeExact</a></span></td>
 <td class="reportText"><span class="text">[public, final, varargs, native]</span></td>
 <td class="reportText"><span class="text">java.lang.Object invokeExact(java.lang.Object[])</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_732">invokeWithArguments</a></span></td>
 <td class="reportText"><span class="text">[public, varargs]</span></td>
 <td class="reportText"><span class="text">java.lang.Object invokeWithArguments(java.lang.Object[])</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_758">invokeWithArguments</a></span></td>
 <td class="reportText"><span class="text">[public]</span></td>
 <td class="reportText"><span class="text">java.lang.Object invokeWithArguments(java.util.List)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">20293454</span></td>
 <td class="reportText"><span class="text"><a href="#src_957">isAncestorLoaderOf</a></span></td>
 <td class="reportText"><span class="text">[private, static]</span></td>
 <td class="reportText"><span class="text">boolean isAncestorLoaderOf(java.lang.ClassLoader,java.lang.ClassLoader)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">60882682</span></td>
 <td class="reportText"><span class="text"><a href="#src_970">isBuiltinLoader</a></span></td>
 <td class="reportText"><span class="text">[private, static]</span></td>
 <td class="reportText"><span class="text">boolean isBuiltinLoader(java.lang.ClassLoader)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_1786">isCrackable</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">boolean isCrackable()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">3209</span></td>
 <td class="reportText"><span class="text"><a href="#src_1781">isInvokeSpecial</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">boolean isInvokeSpecial()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">20295656</span></td>
 <td class="reportText"><span class="text"><a href="#src_913">isSafeToCache</a></span></td>
 <td class="reportText"><span class="text">[private]</span></td>
 <td class="reportText"><span class="text">boolean isSafeToCache(java.lang.invoke.MethodType)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">20284177</span></td>
 <td class="reportText"><span class="text"><a href="#src_1535">isVarargsCollector</a></span></td>
 <td class="reportText"><span class="text">[public]</span></td>
 <td class="reportText"><span class="text">boolean isVarargsCollector()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">20295656</span></td>
 <td class="reportText"><span class="text"><a href="#src_938">keepsAlive</a></span></td>
 <td class="reportText"><span class="text">[private, static]</span></td>
 <td class="reportText"><span class="text">boolean keepsAlive(java.lang.invoke.MethodType,java.lang.ClassLoader)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">40589227</span></td>
 <td class="reportText"><span class="text"><a href="#src_948">keepsAlive</a></span></td>
 <td class="reportText"><span class="text">[private, static]</span></td>
 <td class="reportText"><span class="text">boolean keepsAlive(java.lang.Class,java.lang.ClassLoader)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_0">linkToInterface</a></span></td>
 <td class="reportText"><span class="text">[static, varargs, native]</span></td>
 <td class="reportText"><span class="text">java.lang.Object linkToInterface(java.lang.Object[])</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_0">linkToNative</a></span></td>
 <td class="reportText"><span class="text">[static, varargs, native]</span></td>
 <td class="reportText"><span class="text">java.lang.Object linkToNative(java.lang.Object[])</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_0">linkToSpecial</a></span></td>
 <td class="reportText"><span class="text">[static, varargs, native]</span></td>
 <td class="reportText"><span class="text">java.lang.Object linkToSpecial(java.lang.Object[])</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_0">linkToStatic</a></span></td>
 <td class="reportText"><span class="text">[static, varargs, native]</span></td>
 <td class="reportText"><span class="text">java.lang.Object linkToStatic(java.lang.Object[])</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_0">linkToVirtual</a></span></td>
 <td class="reportText"><span class="text">[static, varargs, native]</span></td>
 <td class="reportText"><span class="text">java.lang.Object linkToVirtual(java.lang.Object[])</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">40593000</span></td>
 <td class="reportText"><span class="text"><a href="#src_1815">maybeCustomize</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">void maybeCustomize()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">20295656</span></td>
 <td class="reportText"><span class="text"><a href="#src_891">setAsTypeCache</a></span></td>
 <td class="reportText"><span class="text">[private]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MethodHandle setAsTypeCache(java.lang.invoke.MethodHandle)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">20309227</span></td>
 <td class="reportText"><span class="text"><a href="#src_1708">setVarargs</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MethodHandle setVarargs(java.lang.invoke.MemberName)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">408</span></td>
 <td class="reportText"><span class="text"><a href="#src_1154">spreadArrayChecks</a></span></td>
 <td class="reportText"><span class="text">[private]</span></td>
 <td class="reportText"><span class="text">void spreadArrayChecks(java.lang.Class,int)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_1687">standardString</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">java.lang.String standardString()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_uncovered"><span class="text">0</span></td>
 <td class="reportText"><span class="text"><a href="#src_1683">toString</a></span></td>
 <td class="reportText"><span class="text">[public]</span></td>
 <td class="reportText"><span class="text">java.lang.String toString()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">307878695</span></td>
 <td class="reportText"><span class="text"><a href="#src_468">type</a></span></td>
 <td class="reportText"><span class="text">[public]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MethodType type()</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">380</span></td>
 <td class="reportText"><span class="text"><a href="#src_1846">updateForm</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">void updateForm(java.util.function.Function)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">912</span></td>
 <td class="reportText"><span class="text"><a href="#src_1720">viewAsType</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MethodHandle viewAsType(java.lang.invoke.MethodType,boolean)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">13992</span></td>
 <td class="reportText"><span class="text"><a href="#src_1726">viewAsTypeChecks</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">boolean viewAsTypeChecks(java.lang.invoke.MethodType,boolean)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">2</span></td>
 <td class="reportText"><span class="text"><a href="#src_1766">withInternalMemberName</a></span></td>
 <td class="reportText"><span class="text">[]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MethodHandle withInternalMemberName(java.lang.invoke.MemberName,boolean)</span></td>
 </tr>
 <tr class="report">
 <td class="reportValue_covered"><span class="text">319</span></td>
 <td class="reportText"><span class="text"><a href="#src_1199">withVarargs</a></span></td>
 <td class="reportText"><span class="text">[public]</span></td>
 <td class="reportText"><span class="text">java.lang.invoke.MethodHandle withVarargs(boolean)</span></td>
 </tr>
 </table>
 <br>
 <table cellspacing="0" cellpadding="0" class="src">
 <tr>
 <td class="numLine">&nbsp;1</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">/*</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;2</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Copyright (c) 2008, 2022, Oracle and/or its affiliates. All rights reserved.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;3</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;4</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;5</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * This code is free software; you can redistribute it and/or modify it</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;6</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * under the terms of the GNU General Public License version 2 only, as</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;7</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * published by the Free Software Foundation.  Oracle designates this</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;8</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * particular file as subject to the "Classpath" exception as provided</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;9</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * by Oracle in the LICENSE file that accompanied this code.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;10</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;11</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * This code is distributed in the hope that it will be useful, but WITHOUT</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;12</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;13</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;14</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * version 2 for more details (a copy is included in the LICENSE file that</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;15</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * accompanied this code).</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;16</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;17</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * You should have received a copy of the GNU General Public License version</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;18</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * 2 along with this work; if not, write to the Free Software Foundation,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;19</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;20</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;21</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;22</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * or visit www.oracle.com if you need additional information or have any</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;23</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * questions.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;24</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;25</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;26</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="keyword">package</span> java.lang.invoke;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;27</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;28</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;29</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="keyword">import</span> jdk.internal.loader.ClassLoaders;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;30</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="keyword">import</span> jdk.internal.vm.annotation.IntrinsicCandidate;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;31</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;32</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="keyword">import</span> java.lang.constant.ClassDesc;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;33</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="keyword">import</span> java.lang.constant.Constable;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;34</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="keyword">import</span> java.lang.constant.DirectMethodHandleDesc;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;35</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="keyword">import</span> java.lang.constant.MethodHandleDesc;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;36</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="keyword">import</span> java.lang.constant.MethodTypeDesc;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;37</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="keyword">import</span> java.lang.ref.SoftReference;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;38</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="keyword">import</span> java.util.Arrays;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;39</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="keyword">import</span> java.util.Objects;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;40</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="keyword">import</span> java.util.Optional;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;41</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="keyword">import</span> java.util.function.Function;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;42</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;43</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="keyword">import</span> <span Class="keyword">static</span> java.lang.invoke.MethodHandleInfo.*;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;44</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="keyword">import</span> <span Class="keyword">static</span> java.lang.invoke.MethodHandleStatics.*;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;45</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="keyword">import</span> <span Class="keyword">static</span> java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;46</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;47</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;48</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * A method handle is a typed, directly executable reference to an underlying method,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;49</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * constructor, field, or similar low-level operation, with optional</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;50</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * transformations of arguments or return values.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;51</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * These transformations are quite general, and include such patterns as</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;52</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * {@linkplain #asType conversion},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;53</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * {@linkplain #bindTo insertion},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;54</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * {@linkplain java.lang.invoke.MethodHandles#dropArguments deletion},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;55</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * and {@linkplain java.lang.invoke.MethodHandles#filterArguments substitution}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;56</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;57</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;h2&#62;Method handle contents&#60;/h2&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;58</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Method handles are dynamically and strongly typed according to their parameter and return types.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;59</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * They are not distinguished by the name or the defining class of their underlying methods.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;60</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * A method handle must be invoked using a symbolic type descriptor which matches</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;61</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * the method handle's own {@linkplain #type() type descriptor}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;62</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;63</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Every method handle reports its type descriptor via the {@link #type() type} accessor.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;64</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * This type descriptor is a {@link java.lang.invoke.MethodType MethodType} object,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;65</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * whose structure is a series of classes, one of which is</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;66</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * the return type of the method (or {@code void.class} if none).</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;67</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;68</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * A method handle's type controls the types of invocations it accepts,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;69</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * and the kinds of transformations that apply to it.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;70</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;71</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * A method handle contains a pair of special invoker methods</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;72</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * called {@link #invokeExact invokeExact} and {@link #invoke invoke}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;73</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Both invoker methods provide direct access to the method handle's</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;74</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * underlying method, constructor, field, or other operation,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;75</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * as modified by transformations of arguments and return values.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;76</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Both invokers accept calls which exactly match the method handle's own type.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;77</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * The plain, inexact invoker also accepts a range of other call types.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;78</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;79</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Method handles are immutable and have no visible state.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;80</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Of course, they can be bound to underlying methods or data which exhibit state.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;81</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * With respect to the Java Memory Model, any method handle will behave</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;82</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * as if all of its (internal) fields are final variables.  This means that any method</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;83</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * handle made visible to the application will always be fully formed.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;84</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * This is true even if the method handle is published through a shared</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;85</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * variable in a data race.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;86</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;87</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Method handles cannot be subclassed by the user.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;88</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Implementations may (or may not) create internal subclasses of {@code MethodHandle}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;89</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * which may be visible via the {@link java.lang.Object#getClass Object.getClass}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;90</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * operation.  The programmer should not draw conclusions about a method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;91</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * from its specific class, as the method handle class hierarchy (if any)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;92</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * may change from time to time or across implementations from different vendors.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;93</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;94</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;h2&#62;Method handle compilation&#60;/h2&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;95</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * A Java method call expression naming {@code invokeExact} or {@code invoke}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;96</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * can invoke a method handle from Java source code.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;97</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * From the viewpoint of source code, these methods can take any arguments</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;98</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * and their result can be cast to any return type.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;99</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Formally this is accomplished by giving the invoker methods</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;100</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * {@code Object} return types and variable arity {@code Object} arguments,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;101</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * but they have an additional quality called &#60;em&#62;signature polymorphism&#60;/em&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;102</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * which connects this freedom of invocation directly to the JVM execution stack.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;103</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;104</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * As is usual with virtual methods, source-level calls to {@code invokeExact}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;105</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * and {@code invoke} compile to an {@code invokevirtual} instruction.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;106</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * More unusually, the compiler must record the actual argument types,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;107</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * and may not perform method invocation conversions on the arguments.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;108</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Instead, it must generate instructions that push them on the stack according</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;109</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * to their own unconverted types.  The method handle object itself is pushed on</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;110</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * the stack before the arguments.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;111</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * The compiler then generates an {@code invokevirtual} instruction that invokes</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;112</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * the method handle with a symbolic type descriptor which describes the argument</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;113</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * and return types.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;114</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;115</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * To issue a complete symbolic type descriptor, the compiler must also determine</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;116</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * the return type.  This is based on a cast on the method invocation expression,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;117</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * if there is one, or else {@code Object} if the invocation is an expression,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;118</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * or else {@code void} if the invocation is a statement.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;119</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * The cast may be to a primitive type (but not {@code void}).</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;120</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;121</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * As a corner case, an uncasted {@code null} argument is given</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;122</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * a symbolic type descriptor of {@code java.lang.Void}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;123</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * The ambiguity with the type {@code Void} is harmless, since there are no references of type</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;124</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * {@code Void} except the null reference.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;125</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;126</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;h2&#62;Method handle invocation&#60;/h2&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;127</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * The first time an {@code invokevirtual} instruction is executed</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;128</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * it is linked by symbolically resolving the names in the instruction</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;129</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * and verifying that the method call is statically legal.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;130</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * This also holds for calls to {@code invokeExact} and {@code invoke}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;131</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * In this case, the symbolic type descriptor emitted by the compiler is checked for</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;132</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * correct syntax, and names it contains are resolved.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;133</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Thus, an {@code invokevirtual} instruction which invokes</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;134</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * a method handle will always link, as long</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;135</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * as the symbolic type descriptor is syntactically well-formed</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;136</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * and the types exist.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;137</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;138</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * When the {@code invokevirtual} is executed after linking,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;139</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * the receiving method handle's type is first checked by the JVM</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;140</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * to ensure that it matches the symbolic type descriptor.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;141</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * If the type match fails, it means that the method which the</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;142</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * caller is invoking is not present on the individual</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;143</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * method handle being invoked.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;144</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;145</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * In the case of {@code invokeExact}, the type descriptor of the invocation</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;146</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * (after resolving symbolic type names) must exactly match the method type</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;147</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * of the receiving method handle.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;148</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * In the case of plain, inexact {@code invoke}, the resolved type descriptor</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;149</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * must be a valid argument to the receiver's {@link #asType asType} method.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;150</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Thus, plain {@code invoke} is more permissive than {@code invokeExact}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;151</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;152</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * After type matching, a call to {@code invokeExact} directly</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;153</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * and immediately invoke the method handle's underlying method</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;154</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * (or other behavior, as the case may be).</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;155</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;156</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * A call to plain {@code invoke} works the same as a call to</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;157</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * {@code invokeExact}, if the symbolic type descriptor specified by the caller</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;158</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * exactly matches the method handle's own type.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;159</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * If there is a type mismatch, {@code invoke} attempts</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;160</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * to adjust the type of the receiving method handle,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;161</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * as if by a call to {@link #asType asType},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;162</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * to obtain an exactly invokable method handle {@code M2}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;163</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * This allows a more powerful negotiation of method type</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;164</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * between caller and callee.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;165</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;166</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * (&#60;em&#62;Note:&#60;/em&#62; The adjusted method handle {@code M2} is not directly observable,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;167</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * and implementations are therefore not required to materialize it.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;168</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;169</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;h2&#62;Invocation checking&#60;/h2&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;170</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * In typical programs, method handle type matching will usually succeed.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;171</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * But if a match fails, the JVM will throw a {@link WrongMethodTypeException},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;172</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * either directly (in the case of {@code invokeExact}) or indirectly as if</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;173</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * by a failed call to {@code asType} (in the case of {@code invoke}).</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;174</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;175</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Thus, a method type mismatch which might show up as a linkage error</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;176</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * in a statically typed program can show up as</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;177</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * a dynamic {@code WrongMethodTypeException}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;178</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * in a program which uses method handles.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;179</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;180</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Because method types contain "live" {@code Class} objects,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;181</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * method type matching takes into account both type names and class loaders.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;182</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Thus, even if a method handle {@code M} is created in one</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;183</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * class loader {@code L1} and used in another {@code L2},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;184</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * method handle calls are type-safe, because the caller's symbolic type</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;185</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * descriptor, as resolved in {@code L2},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;186</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * is matched against the original callee method's symbolic type descriptor,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;187</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * as resolved in {@code L1}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;188</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * The resolution in {@code L1} happens when {@code M} is created</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;189</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * and its type is assigned, while the resolution in {@code L2} happens</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;190</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * when the {@code invokevirtual} instruction is linked.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;191</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;192</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Apart from type descriptor checks,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;193</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * a method handle's capability to call its underlying method is unrestricted.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;194</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * If a method handle is formed on a non-public method by a class</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;195</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * that has access to that method, the resulting handle can be used</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;196</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * in any place by any caller who receives a reference to it.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;197</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;198</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Unlike with the Core Reflection API, where access is checked every time</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;199</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * a reflective method is invoked,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;200</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * method handle access checking is performed</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;201</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;a href="MethodHandles.Lookup.html#access"&#62;when the method handle is created&#60;/a&#62;.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;202</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * In the case of {@code ldc} (see below), access checking is performed as part of linking</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;203</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * the constant pool entry underlying the constant method handle.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;204</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;205</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Thus, handles to non-public methods, or to methods in non-public classes,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;206</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * should generally be kept secret.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;207</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * They should not be passed to untrusted code unless their use from</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;208</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * the untrusted code would be harmless.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;209</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;210</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;h2&#62;Method handle creation&#60;/h2&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;211</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Java code can create a method handle that directly accesses</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;212</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * any method, constructor, or field that is accessible to that code.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;213</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * This is done via a reflective, capability-based API called</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;214</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * {@link java.lang.invoke.MethodHandles.Lookup MethodHandles.Lookup}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;215</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * For example, a static method handle can be obtained</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;216</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * from {@link java.lang.invoke.MethodHandles.Lookup#findStatic Lookup.findStatic}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;217</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * There are also conversion methods from Core Reflection API objects,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;218</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * such as {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;219</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;220</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Like classes and strings, method handles that correspond to accessible</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;221</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * fields, methods, and constructors can also be represented directly</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;222</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * in a class file's constant pool as constants to be loaded by {@code ldc} bytecodes.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;223</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * A new type of constant pool entry, {@code CONSTANT_MethodHandle},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;224</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * refers directly to an associated {@code CONSTANT_Methodref},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;225</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * {@code CONSTANT_InterfaceMethodref}, or {@code CONSTANT_Fieldref}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;226</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * constant pool entry.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;227</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * (For full details on method handle constants, see sections {@jvms</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;228</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * 4.4.8} and {@jvms 5.4.3.5} of the Java Virtual Machine</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;229</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Specification.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;230</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;231</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Method handles produced by lookups or constant loads from methods or</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;232</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * constructors with the variable arity modifier bit ({@code 0x0080})</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;233</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * have a corresponding variable arity, as if they were defined with</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;234</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * the help of {@link #asVarargsCollector asVarargsCollector}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;235</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * or {@link #withVarargs withVarargs}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;236</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;237</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * A method reference may refer either to a static or non-static method.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;238</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * In the non-static case, the method handle type includes an explicit</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;239</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * receiver argument, prepended before any other arguments.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;240</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * In the method handle's type, the initial receiver argument is typed</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;241</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * according to the class under which the method was initially requested.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;242</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * (E.g., if a non-static method handle is obtained via {@code ldc},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;243</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * the type of the receiver is the class named in the constant pool entry.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;244</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;245</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Method handle constants are subject to the same link-time access checks</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;246</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * their corresponding bytecode instructions, and the {@code ldc} instruction</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;247</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * will throw corresponding linkage errors if the bytecode behaviors would</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;248</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * throw such errors.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;249</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;250</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * As a corollary of this, access to protected members is restricted</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;251</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * to receivers only of the accessing class, or one of its subclasses,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;252</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * and the accessing class must in turn be a subclass (or package sibling)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;253</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * of the protected member's defining class.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;254</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * If a method reference refers to a protected non-static method or field</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;255</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * of a class outside the current package, the receiver argument will</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;256</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * be narrowed to the type of the accessing class.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;257</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;258</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * When a method handle to a virtual method is invoked, the method is</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;259</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * always looked up in the receiver (that is, the first argument).</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;260</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;261</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * A non-virtual method handle to a specific virtual method implementation</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;262</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * can also be created.  These do not perform virtual lookup based on</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;263</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * receiver type.  Such a method handle simulates the effect of</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;264</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * an {@code invokespecial} instruction to the same method.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;265</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * A non-virtual method handle can also be created to simulate the effect</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;266</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * of an {@code invokevirtual} or {@code invokeinterface} instruction on</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;267</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * a private method (as applicable).</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;268</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;269</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;h2&#62;Usage examples&#60;/h2&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;270</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Here are some examples of usage:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;271</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * {@snippet lang="java" :</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;272</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">Object x, y; String s; int i;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;273</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodType mt; MethodHandle mh;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;274</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandles.Lookup lookup = MethodHandles.lookup();</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;275</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// mt is (char,char)String</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;276</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">mt = MethodType.methodType(String.class, char.class, char.class);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;277</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">mh = lookup.findVirtual(String.class, "replace", mt);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;278</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">s = (String) mh.invokeExact("daddy",'d','n');</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;279</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// invokeExact(Ljava/lang/String;CC)Ljava/lang/String;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;280</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals(s, "nanny");</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;281</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// weakly typed invocation (using MHs.invoke)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;282</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">s = (String) mh.invokeWithArguments("sappy", 'p', 'v');</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;283</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals(s, "savvy");</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;284</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// mt is (Object[])List</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;285</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">mt = MethodType.methodType(java.util.List.class, Object[].class);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;286</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">mh = lookup.findStatic(java.util.Arrays.class, "asList", mt);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;287</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assert(mh.isVarargsCollector());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;288</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">x = mh.invoke("one", "two");</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;289</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// invoke(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;290</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals(x, java.util.Arrays.asList("one","two"));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;291</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// mt is (Object,Object,Object)Object</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;292</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">mt = MethodType.genericMethodType(3);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;293</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">mh = mh.asType(mt);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;294</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">x = mh.invokeExact((Object)1, (Object)2, (Object)3);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;295</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// invokeExact(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;296</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals(x, java.util.Arrays.asList(1,2,3));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;297</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// mt is ()int</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;298</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">mt = MethodType.methodType(int.class);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;299</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">mh = lookup.findVirtual(java.util.List.class, "size", mt);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;300</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">i = (int) mh.invokeExact(java.util.Arrays.asList(1,2,3));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;301</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// invokeExact(Ljava/util/List;)I</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;302</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assert(i == 3);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;303</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">mt = MethodType.methodType(void.class, String.class);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;304</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">mh = lookup.findVirtual(java.io.PrintStream.class, "println", mt);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;305</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">mh.invokeExact(System.out, "Hello, world.");</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;306</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// invokeExact(Ljava/io/PrintStream;Ljava/lang/String;)V</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;307</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;308</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Each of the above calls to {@code invokeExact} or plain {@code invoke}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;309</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * generates a single invokevirtual instruction with</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;310</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * the symbolic type descriptor indicated in the following comment.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;311</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * In these examples, the helper method {@code assertEquals} is assumed to</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;312</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * be a method which calls {@link java.util.Objects#equals(Object,Object) Objects.equals}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;313</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * on its arguments, and asserts that the result is true.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;314</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;315</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;h2&#62;Exceptions&#60;/h2&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;316</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * The methods {@code invokeExact} and {@code invoke} are declared</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;317</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * to throw {@link java.lang.Throwable Throwable},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;318</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * which is to say that there is no static restriction on what a method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;319</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * can throw.  Since the JVM does not distinguish between checked</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;320</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * and unchecked exceptions (other than by their class, of course),</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;321</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * there is no particular effect on bytecode shape from ascribing</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;322</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * checked exceptions to method handle invocations.  But in Java source</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;323</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * code, methods which perform method handle calls must either explicitly</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;324</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * throw {@code Throwable}, or else must catch all</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;325</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * throwables locally, rethrowing only those which are legal in the context,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;326</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * and wrapping ones which are illegal.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;327</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;328</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;h2&#62;&#60;a id="sigpoly"&#62;&#60;/a&#62;Signature polymorphism&#60;/h2&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;329</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * The unusual compilation and linkage behavior of</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;330</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * {@code invokeExact} and plain {@code invoke}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;331</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * is referenced by the term &#60;em&#62;signature polymorphism&#60;/em&#62;.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;332</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * As defined in the Java Language Specification,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;333</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * a signature polymorphic method is one which can operate with</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;334</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * any of a wide range of call signatures and return types.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;335</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;336</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * In source code, a call to a signature polymorphic method will</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;337</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * compile, regardless of the requested symbolic type descriptor.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;338</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * As usual, the Java compiler emits an {@code invokevirtual}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;339</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * instruction with the given symbolic type descriptor against the named method.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;340</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * The unusual part is that the symbolic type descriptor is derived from</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;341</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * the actual argument and return types, not from the method declaration.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;342</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;343</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * When the JVM processes bytecode containing signature polymorphic calls,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;344</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * it will successfully link any such call, regardless of its symbolic type descriptor.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;345</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * (In order to retain type safety, the JVM will guard such calls with suitable</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;346</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * dynamic type checks, as described elsewhere.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;347</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;348</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Bytecode generators, including the compiler back end, are required to emit</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;349</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * untransformed symbolic type descriptors for these methods.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;350</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Tools which determine symbolic linkage are required to accept such</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;351</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * untransformed descriptors, without reporting linkage errors.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;352</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;353</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;h2&#62;Interoperation between method handles and the Core Reflection API&#60;/h2&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;354</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Using factory methods in the {@link java.lang.invoke.MethodHandles.Lookup Lookup} API,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;355</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * any class member represented by a Core Reflection API object</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;356</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * can be converted to a behaviorally equivalent method handle.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;357</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * For example, a reflective {@link java.lang.reflect.Method Method} can</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;358</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * be converted to a method handle using</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;359</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;360</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * The resulting method handles generally provide more direct and efficient</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;361</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * access to the underlying class members.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;362</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;363</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * As a special case,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;364</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * when the Core Reflection API is used to view the signature polymorphic</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;365</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * methods {@code invokeExact} or plain {@code invoke} in this class,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;366</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * they appear as ordinary non-polymorphic methods.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;367</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Their reflective appearance, as viewed by</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;368</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * {@link java.lang.Class#getDeclaredMethod Class.getDeclaredMethod},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;369</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * is unaffected by their special status in this API.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;370</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * For example, {@link java.lang.reflect.Method#getModifiers Method.getModifiers}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;371</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * will report exactly those modifier bits required for any similarly</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;372</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * declared method, including in this case {@code native} and {@code varargs} bits.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;373</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;374</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * As with any reflected method, these methods (when reflected) may be</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;375</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * invoked via {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;376</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * However, such reflective calls do not result in method handle invocations.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;377</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Such a call, if passed the required argument</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;378</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * (a single one, of type {@code Object[]}), will ignore the argument and</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;379</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * will throw an {@code UnsupportedOperationException}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;380</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;381</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Since {@code invokevirtual} instructions can natively</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;382</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * invoke method handles under any symbolic type descriptor, this reflective view conflicts</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;383</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * with the normal presentation of these methods via bytecodes.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;384</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Thus, these two native methods, when reflectively viewed by</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;385</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * {@code Class.getDeclaredMethod}, may be regarded as placeholders only.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;386</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;387</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * In order to obtain an invoker method for a particular type descriptor,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;388</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * use {@link java.lang.invoke.MethodHandles#exactInvoker MethodHandles.exactInvoker},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;389</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * or {@link java.lang.invoke.MethodHandles#invoker MethodHandles.invoker}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;390</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * The {@link java.lang.invoke.MethodHandles.Lookup#findVirtual Lookup.findVirtual}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;391</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * API is also able to return a method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;392</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * to call {@code invokeExact} or plain {@code invoke},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;393</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * for any specified type descriptor .</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;394</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;395</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;h2&#62;Interoperation between method handles and Java generics&#60;/h2&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;396</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * A method handle can be obtained on a method, constructor, or field</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;397</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * which is declared with Java generic types.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;398</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * As with the Core Reflection API, the type of the method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;399</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * will be constructed from the erasure of the source-level type.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;400</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * When a method handle is invoked, the types of its arguments</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;401</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * or the return value cast type may be generic types or type instances.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;402</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * If this occurs, the compiler will replace those</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;403</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * types by their erasures when it constructs the symbolic type descriptor</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;404</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * for the {@code invokevirtual} instruction.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;405</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;406</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Method handles do not represent</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;407</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * their function-like types in terms of Java parameterized (generic) types,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;408</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * because there are three mismatches between function-like types and parameterized</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;409</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Java types.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;410</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;ul&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;411</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;li&#62;Method types range over all possible arities,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;412</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * from no arguments to up to the  &#60;a href="MethodHandle.html#maxarity"&#62;maximum number&#60;/a&#62; of allowed arguments.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;413</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Generics are not variadic, and so cannot represent this.&#60;/li&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;414</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;li&#62;Method types can specify arguments of primitive types,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;415</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * which Java generic types cannot range over.&#60;/li&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;416</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;li&#62;Higher order functions over method handles (combinators) are</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;417</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * often generic across a wide range of function types, including</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;418</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * those of multiple arities.  It is impossible to represent such</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;419</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * genericity with a Java type parameter.&#60;/li&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;420</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;/ul&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;421</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;422</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;h2&#62;&#60;a id="maxarity"&#62;&#60;/a&#62;Arity limits&#60;/h2&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;423</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * The JVM imposes on all methods and constructors of any kind an absolute</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;424</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * limit of 255 stacked arguments.  This limit can appear more restrictive</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;425</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * in certain cases:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;426</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;ul&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;427</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;li&#62;A {@code long} or {@code double} argument counts (for purposes of arity limits) as two argument slots.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;428</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;li&#62;A non-static method consumes an extra argument for the object on which the method is called.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;429</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;li&#62;A constructor consumes an extra argument for the object which is being constructed.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;430</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;li&#62;Since a method handle&#38;rsquo;s {@code invoke} method (or other signature-polymorphic method) is non-virtual,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;431</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> *     it consumes an extra argument for the method handle itself, in addition to any non-virtual receiver object.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;432</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * &#60;/ul&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;433</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * These limits imply that certain method handles cannot be created, solely because of the JVM limit on stacked arguments.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;434</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * For example, if a static JVM method accepts exactly 255 arguments, a method handle cannot be created for it.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;435</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * Attempts to create method handles with impossible method types lead to an {@link IllegalArgumentException}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;436</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * In particular, a method handle&#38;rsquo;s type must not have an arity of the exact maximum 255.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;437</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;438</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * @see MethodType</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;439</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * @see MethodHandles</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;440</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * @author John Rose, JSR 292 EG</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;441</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> * @since 1.7</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;442</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment"> */</span></pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;443<a name="src_443"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="keyword">public</span> <span Class="keyword">abstract</span> sealed <span Class="keyword">class</span> MethodHandle <span Class="keyword">implements</span> Constable</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;444</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    permits NativeMethodHandle, DirectMethodHandle,</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;445</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            DelegatingMethodHandle, BoundMethodHandle {</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;446</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;447</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;448</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Internal marker interface which distinguishes (to the Java compiler)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;449</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * those methods which are &#60;a href="MethodHandle.html#sigpoly"&#62;signature polymorphic&#60;/a&#62;.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;450</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;451</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD})</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;452</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;453</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    @<span Class="keyword">interface</span> PolymorphicSignature { }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;454</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;455</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">private</span> <span Class="keyword">final</span> MethodType type;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;456</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">private*/</span> <span Class="keyword">final</span> LambdaForm form; <span Class="comment">// form is not private so that invokers can easily fetch it</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;457</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">private</span> MethodHandle asTypeCache;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;458</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">private</span> SoftReference&#60;MethodHandle&#62; asTypeSoftCache;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;459</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;460</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">private</span> <span Class="keyword">byte</span> customizationCount;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;461</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;462</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;463</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Reports the type of this method handle.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;464</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Every invocation of this method handle via {@code invokeExact} must exactly match this type.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;465</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return the method handle type</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;466</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;467</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">public</span> MethodType type() {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;468<a name="src_468"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> type;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;469</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;470</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;471</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;472</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Package-private constructor for the method handle implementation hierarchy.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;473</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Method handle inheritance will be contained completely within</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;474</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the {@code java.lang.invoke} package.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;475</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;476</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">// @param type type (permanently assigned) of the new method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;477</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;478<a name="src_478"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    MethodHandle(MethodType type, LambdaForm form) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;479</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">this</span>.type = Objects.requireNonNull(type);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;480</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">this</span>.form = Objects.requireNonNull(form).uncustomize();</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;481</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;482</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">this</span>.form.prepare();  <span Class="comment">// TO DO:  Try to delay this step until just before invocation.</span></pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;483</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;484</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;485</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;486</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Invokes the method handle, allowing any caller type descriptor, but requiring an exact type match.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;487</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The symbolic type descriptor at the call site of {@code invokeExact} must</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;488</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * exactly match this method handle's {@link #type() type}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;489</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * No conversions are allowed on arguments or return values.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;490</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;491</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * When this method is observed via the Core Reflection API,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;492</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * it will appear as a single native method, taking an object array and returning an object.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;493</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * If this native method is invoked directly via</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;494</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}, via JNI,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;495</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * or indirectly via {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;496</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * it will throw an {@code UnsupportedOperationException}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;497</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param args the signature-polymorphic parameter list, statically represented using varargs</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;498</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return the signature-polymorphic result, statically represented using {@code Object}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;499</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws WrongMethodTypeException if the target's type is not identical with the caller's symbolic type descriptor</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;500</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws Throwable anything thrown by the underlying method propagates unchanged through the method handle call</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;501</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;502</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    @IntrinsicCandidate</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;503</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">public</span> <span Class="keyword">final</span> <span Class="keyword">native</span> @PolymorphicSignature Object invokeExact(Object... args) <span Class="keyword">throws</span> Throwable;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;504</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;505</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;506</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Invokes the method handle, allowing any caller type descriptor,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;507</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * and optionally performing conversions on arguments and return values.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;508</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;509</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * If the call site's symbolic type descriptor exactly matches this method handle's {@link #type() type},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;510</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the call proceeds as if by {@link #invokeExact invokeExact}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;511</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;512</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Otherwise, the call proceeds as if this method handle were first</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;513</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * adjusted by calling {@link #asType asType} to adjust this method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;514</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * to the required type, and then the call proceeds as if by</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;515</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@link #invokeExact invokeExact} on the adjusted method handle.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;516</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;517</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * There is no guarantee that the {@code asType} call is actually made.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;518</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * If the JVM can predict the results of making the call, it may perform</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;519</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * adaptations directly on the caller's arguments,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;520</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * and call the target method handle according to its own exact type.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;521</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;522</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The resolved type descriptor at the call site of {@code invoke} must</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;523</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * be a valid argument to the receivers {@code asType} method.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;524</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * In particular, the caller must specify the same argument arity</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;525</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * as the callee's type,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;526</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * if the callee is not a {@linkplain #asVarargsCollector variable arity collector}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;527</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;528</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * When this method is observed via the Core Reflection API,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;529</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * it will appear as a single native method, taking an object array and returning an object.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;530</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * If this native method is invoked directly via</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;531</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}, via JNI,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;532</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * or indirectly via {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;533</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * it will throw an {@code UnsupportedOperationException}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;534</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param args the signature-polymorphic parameter list, statically represented using varargs</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;535</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return the signature-polymorphic result, statically represented using {@code Object}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;536</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws WrongMethodTypeException if the target's type cannot be adjusted to the caller's symbolic type descriptor</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;537</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws ClassCastException if the target's type can be adjusted to the caller, but a reference cast fails</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;538</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws Throwable anything thrown by the underlying method propagates unchanged through the method handle call</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;539</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;540</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    @IntrinsicCandidate</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;541</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">public</span> <span Class="keyword">final</span> <span Class="keyword">native</span> @PolymorphicSignature Object invoke(Object... args) <span Class="keyword">throws</span> Throwable;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;542</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;543</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;544</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Private method for trusted invocation of a method handle respecting simplified signatures.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;545</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Type mismatches will not throw {@code WrongMethodTypeException}, but could crash the JVM.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;546</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;547</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The caller signature is restricted to the following basic types:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;548</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Object, int, long, float, double, and void return.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;549</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;550</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The caller is responsible for maintaining type correctness by ensuring</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;551</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * that the each outgoing argument value is a member of the range of the corresponding</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;552</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * callee argument type.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;553</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * (The caller should therefore issue appropriate casts and integer narrowing</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;554</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * operations on outgoing argument values.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;555</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The caller can assume that the incoming result value is part of the range</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;556</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * of the callee's return type.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;557</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param args the signature-polymorphic parameter list, statically represented using varargs</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;558</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return the signature-polymorphic result, statically represented using {@code Object}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;559</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;560</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    @IntrinsicCandidate</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;561</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;562</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">final</span> <span Class="keyword">native</span> @PolymorphicSignature Object invokeBasic(Object... args) <span Class="keyword">throws</span> Throwable;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;563</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;564</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;565</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Private method for trusted invocation of a MemberName of kind {@code REF_invokeVirtual}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;566</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The caller signature is restricted to basic types as with {@code invokeBasic}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;567</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The trailing (not leading) argument must be a MemberName.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;568</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param args the signature-polymorphic parameter list, statically represented using varargs</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;569</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return the signature-polymorphic result, statically represented using {@code Object}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;570</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;571</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    @IntrinsicCandidate</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;572</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;573</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">static</span> <span Class="keyword">native</span> @PolymorphicSignature Object linkToVirtual(Object... args) <span Class="keyword">throws</span> Throwable;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;574</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;575</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;576</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Private method for trusted invocation of a MemberName of kind {@code REF_invokeStatic}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;577</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The caller signature is restricted to basic types as with {@code invokeBasic}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;578</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The trailing (not leading) argument must be a MemberName.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;579</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param args the signature-polymorphic parameter list, statically represented using varargs</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;580</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return the signature-polymorphic result, statically represented using {@code Object}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;581</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;582</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    @IntrinsicCandidate</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;583</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;584</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">static</span> <span Class="keyword">native</span> @PolymorphicSignature Object linkToStatic(Object... args) <span Class="keyword">throws</span> Throwable;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;585</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;586</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;587</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Private method for trusted invocation of a MemberName of kind {@code REF_invokeSpecial}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;588</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The caller signature is restricted to basic types as with {@code invokeBasic}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;589</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The trailing (not leading) argument must be a MemberName.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;590</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param args the signature-polymorphic parameter list, statically represented using varargs</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;591</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return the signature-polymorphic result, statically represented using {@code Object}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;592</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;593</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    @IntrinsicCandidate</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;594</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;595</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">static</span> <span Class="keyword">native</span> @PolymorphicSignature Object linkToSpecial(Object... args) <span Class="keyword">throws</span> Throwable;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;596</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;597</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;598</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Private method for trusted invocation of a MemberName of kind {@code REF_invokeInterface}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;599</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The caller signature is restricted to basic types as with {@code invokeBasic}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;600</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The trailing (not leading) argument must be a MemberName.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;601</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param args the signature-polymorphic parameter list, statically represented using varargs</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;602</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return the signature-polymorphic result, statically represented using {@code Object}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;603</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;604</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    @IntrinsicCandidate</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;605</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;606</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">static</span> <span Class="keyword">native</span> @PolymorphicSignature Object linkToInterface(Object... args) <span Class="keyword">throws</span> Throwable;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;607</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;608</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">* TODO */</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;609</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    @IntrinsicCandidate</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;610</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span> <span Class="keyword">static</span> <span Class="keyword">native</span> @PolymorphicSignature Object linkToNative(Object... args) <span Class="keyword">throws</span> Throwable;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;611</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;612</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;613</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Performs a variable arity invocation, passing the arguments in the given array</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;614</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * to the method handle, as if via an inexact {@link #invoke invoke} from a call site</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;615</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * which mentions only the type {@code Object}, and whose actual argument count is the length</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;616</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * of the argument array.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;617</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;618</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Specifically, execution proceeds as if by the following steps,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;619</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * although the methods are not guaranteed to be called if the JVM</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;620</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * can predict their effects.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;621</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;ul&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;622</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;Determine the length of the argument array as {@code N}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;623</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     For a null reference, {@code N=0}. &#60;/li&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;624</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;Collect the {@code N} elements of the array as a logical</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;625</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     argument list, each argument statically typed as an {@code Object}. &#60;/li&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;626</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;Determine, as {@code M}, the parameter count of the type of this</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;627</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     method handle. &#60;/li&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;628</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;Determine the general type {@code TN} of {@code N} arguments or</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;629</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     {@code M} arguments, if smaller than {@code N}, as</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;630</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     {@code TN=MethodType.genericMethodType(Math.min(N, M))}.&#60;/li&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;631</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;If {@code N} is greater than {@code M}, perform the following</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;632</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     checks and actions to shorten the logical argument list: &#60;ul&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;633</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     &#60;li&#62;Check that this method handle has variable arity with a</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;634</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         {@linkplain MethodType#lastParameterType trailing parameter}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;635</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         of some array type {@code A[]}.  If not, fail with a</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;636</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         {@code WrongMethodTypeException}. &#60;/li&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;637</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     &#60;li&#62;Collect the trailing elements (there are {@code N-M+1} of them)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;638</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         from the logical argument list into a single array of</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;639</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         type {@code A[]}, using {@code asType} conversions to</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;640</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         convert each trailing argument to type {@code A}. &#60;/li&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;641</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     &#60;li&#62;If any of these conversions proves impossible, fail with either</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;642</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         a {@code ClassCastException} if any trailing element cannot be</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;643</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         cast to {@code A} or a {@code NullPointerException} if any</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;644</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         trailing element is {@code null} and {@code A} is not a reference</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;645</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         type. &#60;/li&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;646</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     &#60;li&#62;Replace the logical arguments gathered into the array of</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;647</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         type {@code A[]} with the array itself, thus shortening</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;648</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         the argument list to length {@code M}. This final argument</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;649</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         retains the static type {@code A[]}.&#60;/li&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;650</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     &#60;li&#62;Adjust the type {@code TN} by changing the {@code N}th</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;651</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         parameter type from {@code Object} to {@code A[]}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;652</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     &#60;/ul&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;653</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;Force the original target method handle {@code MH0} to the</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;654</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     required type, as {@code MH1 = MH0.asType(TN)}. &#60;/li&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;655</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;Spread the argument list into {@code N} separate arguments {@code A0, ...}. &#60;/li&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;656</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;Invoke the type-adjusted method handle on the unpacked arguments:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;657</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     MH1.invokeExact(A0, ...). &#60;/li&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;658</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;Take the return value as an {@code Object} reference. &#60;/li&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;659</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;/ul&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;660</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;661</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * If the target method handle has variable arity, and the argument list is longer</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;662</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * than that arity, the excess arguments, starting at the position of the trailing</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;663</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * array argument, will be gathered (if possible, as if by {@code asType} conversions)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;664</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * into an array of the appropriate type, and invocation will proceed on the</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;665</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * shortened argument list.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;666</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * In this way, &#60;em&#62;jumbo argument lists&#60;/em&#62; which would spread into more</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;667</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * than 254 slots can still be processed uniformly.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;668</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;669</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Unlike the {@link #invoke(Object...) generic} invocation mode, which can</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;670</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * "recycle" an array argument, passing it directly to the target method,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;671</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * this invocation mode &#60;em&#62;always&#60;/em&#62; creates a new array parameter, even</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;672</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * if the original array passed to {@code invokeWithArguments} would have</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;673</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * been acceptable as a direct argument to the target method.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;674</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Even if the number {@code M} of actual arguments is the arity {@code N},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;675</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * and the last argument is dynamically a suitable array of type {@code A[]},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;676</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * it will still be boxed into a new one-element array, since the call</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;677</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * site statically types the argument as {@code Object}, not an array type.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;678</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * This is not a special rule for this method, but rather a regular effect</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;679</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * of the {@linkplain #asVarargsCollector rules for variable-arity invocation}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;680</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;681</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Because of the action of the {@code asType} step, the following argument</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;682</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * conversions are applied as necessary:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;683</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;ul&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;684</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;reference casting</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;685</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;unboxing</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;686</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;widening primitive conversions</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;687</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;variable arity conversion</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;688</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;/ul&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;689</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;690</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The result returned by the call is boxed if it is a primitive,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;691</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * or forced to null if the return type is void.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;692</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;693</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Unlike the signature polymorphic methods {@code invokeExact} and {@code invoke},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;694</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@code invokeWithArguments} can be accessed normally via the Core Reflection API and JNI.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;695</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * It can therefore be used as a bridge between native or reflective code and method handles.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;696</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @apiNote</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;697</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * This call is approximately equivalent to the following code:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;698</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@snippet lang="java" :</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;699</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * // for jumbo argument lists, adapt varargs explicitly:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;700</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * int N = (arguments == null? 0: arguments.length);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;701</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * int M = this.type.parameterCount();</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;702</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * int MAX_SAFE = 127;  // 127 longs require 254 slots, which is OK</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;703</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * if (N &#62; MAX_SAFE &#38;&#38; N &#62; M &#38;&#38; this.isVarargsCollector()) {</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;704</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *   Class&#60;?&#62; arrayType = this.type().lastParameterType();</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;705</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *   Class&#60;?&#62; elemType = arrayType.getComponentType();</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;706</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *   if (elemType != null) {</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;707</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     Object args2 = Array.newInstance(elemType, M);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;708</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     MethodHandle arraySetter = MethodHandles.arrayElementSetter(arrayType);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;709</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     for (int i = 0; i &#60; M; i++) {</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;710</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *       arraySetter.invoke(args2, i, arguments[M-1 + i]);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;711</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;712</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     arguments = Arrays.copyOf(arguments, M);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;713</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     arguments[M-1] = args2;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;714</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     return this.asFixedArity().invokeWithArguments(arguments);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;715</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *   }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;716</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * } // done with explicit varargs processing</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;717</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;718</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * // Handle fixed arity and non-jumbo variable arity invocation.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;719</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * MethodHandle invoker = MethodHandles.spreadInvoker(this.type(), 0);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;720</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Object result = invoker.invokeExact(this, arguments);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;721</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;722</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;723</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param arguments the arguments to pass to the target</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;724</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return the result returned by the target</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;725</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws ClassCastException if an argument cannot be converted by reference casting</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;726</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws WrongMethodTypeException if the target's type cannot be adjusted to take the given number of {@code Object} arguments</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;727</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws Throwable anything thrown by the target method invocation</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;728</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see MethodHandles#spreadInvoker</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;729</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;730</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">public</span> Object invokeWithArguments(Object... arguments) <span Class="keyword">throws</span> Throwable {</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;731</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="comment">// Note: Jumbo argument lists are handled in the variable-arity subclass.</span></pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;732<a name="src_732"></a></td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        MethodType invocationType = MethodType.genericMethodType(arguments == <span Class="keyword">null</span> ? 0 : arguments.length);</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;733</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/3&nbsp;Branch:&nbsp;0/2&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> invocationType.invokers().spreadInvoker(0).invokeExact(asType(invocationType), arguments);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;734</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;735</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;736</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;737</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Performs a variable arity invocation, passing the arguments in the given list</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;738</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * to the method handle, as if via an inexact {@link #invoke invoke} from a call site</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;739</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * which mentions only the type {@code Object}, and whose actual argument count is the length</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;740</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * of the argument list.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;741</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;742</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * This method is also equivalent to the following code:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;743</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@snippet lang="java" :</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;744</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *   invokeWithArguments(arguments.toArray())</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;745</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;746</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;747</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Jumbo-sized lists are acceptable if this method handle has variable arity.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;748</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * See {@link #invokeWithArguments(Object[])} for details.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;749</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;750</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param arguments the arguments to pass to the target</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;751</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return the result returned by the target</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;752</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws NullPointerException if {@code arguments} is a null reference</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;753</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws ClassCastException if an argument cannot be converted by reference casting</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;754</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws WrongMethodTypeException if the target's type cannot be adjusted to take the given number of {@code Object} arguments</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;755</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws Throwable anything thrown by the target method invocation</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;756</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;757</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">public</span> Object invokeWithArguments(java.util.List&#60;?&#62; arguments) <span Class="keyword">throws</span> Throwable {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;758<a name="src_758"></a></td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> invokeWithArguments(arguments.toArray());</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;759</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;760</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;761</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;762</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Produces an adapter method handle which adapts the type of the</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;763</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * current method handle to a new type.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;764</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The resulting method handle is guaranteed to report a type</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;765</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * which is equal to the desired new type.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;766</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;767</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * If the original type and new type are equal, returns {@code this}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;768</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;769</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The new method handle, when invoked, will perform the following</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;770</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * steps:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;771</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;ul&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;772</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;Convert the incoming argument list to match the original</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;773</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     method handle's argument list.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;774</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;Invoke the original method handle on the converted argument list.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;775</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;Convert any result returned by the original method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;776</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     to the return type of new method handle.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;777</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;/ul&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;778</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;779</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * This method provides the crucial behavioral difference between</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;780</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@link #invokeExact invokeExact} and plain, inexact {@link #invoke invoke}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;781</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The two methods</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;782</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * perform the same steps when the caller's type descriptor exactly matches</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;783</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the callee's, but when the types differ, plain {@link #invoke invoke}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;784</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * also calls {@code asType} (or some internal equivalent) in order</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;785</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * to match up the caller's and callee's types.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;786</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;787</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * If the current method is a variable arity method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;788</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * argument list conversion may involve the conversion and collection</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;789</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * of several arguments into an array, as</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;790</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@linkplain #asVarargsCollector described elsewhere}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;791</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * In every other case, all conversions are applied &#60;em&#62;pairwise&#60;/em&#62;,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;792</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * which means that each argument or return value is converted to</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;793</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * exactly one argument or return value (or no return value).</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;794</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The applied conversions are defined by consulting</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;795</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the corresponding component types of the old and new</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;796</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * method handle types.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;797</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;798</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Let &#60;em&#62;T0&#60;/em&#62; and &#60;em&#62;T1&#60;/em&#62; be corresponding new and old parameter types,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;799</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * or old and new return types.  Specifically, for some valid index {@code i}, let</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;800</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;em&#62;T0&#60;/em&#62;{@code =newType.parameterType(i)} and &#60;em&#62;T1&#60;/em&#62;{@code =this.type().parameterType(i)}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;801</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Or else, going the other way for return values, let</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;802</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;em&#62;T0&#60;/em&#62;{@code =this.type().returnType()} and &#60;em&#62;T1&#60;/em&#62;{@code =newType.returnType()}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;803</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * If the types are the same, the new method handle makes no change</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;804</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * to the corresponding argument or return value (if any).</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;805</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Otherwise, one of the following conversions is applied</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;806</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * if possible:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;807</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;ul&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;808</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;If &#60;em&#62;T0&#60;/em&#62; and &#60;em&#62;T1&#60;/em&#62; are references, then a cast to &#60;em&#62;T1&#60;/em&#62; is applied.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;809</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     (The types do not need to be related in any particular way.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;810</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     This is because a dynamic value of null can convert to any reference type.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;811</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;If &#60;em&#62;T0&#60;/em&#62; and &#60;em&#62;T1&#60;/em&#62; are primitives, then a Java method invocation</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;812</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     conversion (JLS {@jls 5.3}) is applied, if one exists.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;813</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     (Specifically, &#60;em&#62;T0&#60;/em&#62; must convert to &#60;em&#62;T1&#60;/em&#62; by a widening primitive conversion.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;814</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;If &#60;em&#62;T0&#60;/em&#62; is a primitive and &#60;em&#62;T1&#60;/em&#62; a reference,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;815</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     a Java casting conversion (JLS {@jls 5.5}) is applied if one exists.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;816</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     (Specifically, the value is boxed from &#60;em&#62;T0&#60;/em&#62; to its wrapper class,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;817</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     which is then widened as needed to &#60;em&#62;T1&#60;/em&#62;.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;818</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;If &#60;em&#62;T0&#60;/em&#62; is a reference and &#60;em&#62;T1&#60;/em&#62; a primitive, an unboxing</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;819</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     conversion will be applied at runtime, possibly followed</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;820</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     by a Java method invocation conversion (JLS {@jls 5.3})</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;821</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     on the primitive value.  (These are the primitive widening conversions.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;822</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     &#60;em&#62;T0&#60;/em&#62; must be a wrapper class or a supertype of one.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;823</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     (In the case where &#60;em&#62;T0&#60;/em&#62; is Object, these are the conversions</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;824</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     allowed by {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;825</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     The unboxing conversion must have a possibility of success, which means that</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;826</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     if &#60;em&#62;T0&#60;/em&#62; is not itself a wrapper class, there must exist at least one</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;827</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     wrapper class &#60;em&#62;TW&#60;/em&#62; which is a subtype of &#60;em&#62;T0&#60;/em&#62; and whose unboxed</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;828</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     primitive value can be widened to &#60;em&#62;T1&#60;/em&#62;.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;829</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;If the return type &#60;em&#62;T1&#60;/em&#62; is marked as void, any returned value is discarded</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;830</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;If the return type &#60;em&#62;T0&#60;/em&#62; is void and &#60;em&#62;T1&#60;/em&#62; a reference, a null value is introduced.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;831</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;If the return type &#60;em&#62;T0&#60;/em&#62; is void and &#60;em&#62;T1&#60;/em&#62; a primitive,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;832</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     a zero value is introduced.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;833</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;/ul&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;834</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * (&#60;em&#62;Note:&#60;/em&#62; Both &#60;em&#62;T0&#60;/em&#62; and &#60;em&#62;T1&#60;/em&#62; may be regarded as static types,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;835</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * because neither corresponds specifically to the &#60;em&#62;dynamic type&#60;/em&#62; of any</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;836</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * actual argument or return value.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;837</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;838</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The method handle conversion cannot be made if any one of the required</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;839</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * pairwise conversions cannot be made.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;840</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;841</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * At runtime, the conversions applied to reference arguments</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;842</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * or return values may require additional runtime checks which can fail.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;843</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * An unboxing operation may fail because the original reference is null,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;844</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * causing a {@link java.lang.NullPointerException NullPointerException}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;845</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * An unboxing operation or a reference cast may also fail on a reference</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;846</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * to an object of the wrong type,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;847</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * causing a {@link java.lang.ClassCastException ClassCastException}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;848</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Although an unboxing operation may accept several kinds of wrappers,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;849</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * if none are available, a {@code ClassCastException} will be thrown.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;850</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;851</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param newType the expected type of the new method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;852</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return a method handle which delegates to {@code this} after performing</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;853</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *           any necessary argument conversions, and arranges for any</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;854</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *           necessary return value conversions</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;855</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws NullPointerException if {@code newType} is a null reference</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;856</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws WrongMethodTypeException if the conversion cannot be made</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;857</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see MethodHandles#explicitCastArguments</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;858</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;859</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">public</span> <span Class="keyword">final</span> MethodHandle asType(MethodType newType) {</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;860</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="comment">// Fast path alternative to a heavyweight {@code asType} call.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;861</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="comment">// Return 'this' if the conversion will be a no-op.</span></pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;862<a name="src_862"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (newType == type) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;863</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">return</span> <span Class="keyword">this</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;864</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;865</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="comment">// Return 'this.asTypeCache' if the conversion is already memoized.</span></pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;866</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        MethodHandle at = asTypeCached(newType);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;867</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (at != <span Class="keyword">null</span>) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;868</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">return</span> at;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;869</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;870</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> setAsTypeCache(asTypeUncached(newType));</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;871</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;872</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;873</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">private</span> MethodHandle asTypeCached(MethodType newType) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;874<a name="src_874"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        MethodHandle atc = asTypeCache;</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;875</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (atc != <span Class="keyword">null</span> &#38;&#38; newType == atc.type) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;876</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">return</span> atc; <span Class="comment">// cache hit</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;877</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;878</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;2/2&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        SoftReference&#60;MethodHandle&#62; softCache = asTypeSoftCache;</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;879</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (softCache != <span Class="keyword">null</span>) {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;880</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            atc = softCache.get();</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;881</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">if</span> (atc != <span Class="keyword">null</span> &#38;&#38; newType == atc.type) {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;882</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                <span Class="keyword">return</span> atc; <span Class="comment">// soft cache hit</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;883</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;884</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;885</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;2/3&nbsp;Branch:&nbsp;2/5&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> <span Class="keyword">null</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;886</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;887</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;888</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">private</span> MethodHandle setAsTypeCache(MethodHandle at) {</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;889</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="comment">// Don't introduce a strong reference in the cache if newType depends on any class loader other than</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;890</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="comment">// current method handle already does to avoid class loader leaks.</span></pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;891<a name="src_891"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (isSafeToCache(at.type)) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;892</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            asTypeCache = at;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;893</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        } <span Class="keyword">else</span> {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;894</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            asTypeSoftCache = <span Class="keyword">new</span> SoftReference&#60;&#62;(at);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;895</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;896</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> at;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;897</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;898</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;899</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">* Override this to change asType behavior. */</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;900</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;901</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    MethodHandle asTypeUncached(MethodType newType) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;902<a name="src_902"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (!type.isConvertibleTo(newType)) {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;903</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">throw</span> <span Class="keyword">new</span> WrongMethodTypeException(<span Class="string">"cannot convert "</span> + <span Class="keyword">this</span> + <span Class="string">" to "</span> + newType);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;904</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;905</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> MethodHandleImpl.makePairwiseConvert(<span Class="keyword">this</span>, newType, <span Class="keyword">true</span>);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;906</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;907</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;908</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;909</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Returns true if {@code newType} does not depend on any class loader other than current method handle already does.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;910</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * May conservatively return false in order to be efficient.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;911</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;912</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">private</span> <span Class="keyword">boolean</span> isSafeToCache(MethodType newType) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;913<a name="src_913"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        ClassLoader loader = getApproximateCommonClassLoader(type);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;914</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> keepsAlive(newType, loader);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;915</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;916</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;917</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;918</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Tries to find the most specific {@code ClassLoader} which keeps all the classes mentioned in {@code mt} alive.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;919</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * In the worst case, returns a {@code ClassLoader} which relates to some of the classes mentioned in {@code mt}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;920</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;921</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">private</span> <span Class="keyword">static</span> ClassLoader getApproximateCommonClassLoader(MethodType mt) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;922<a name="src_922"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        ClassLoader loader = mt.rtype().getClassLoader();</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;923</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">for</span> (Class&#60;?&#62; ptype : mt.ptypes()) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;924</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            ClassLoader ploader = ptype.getClassLoader();</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;925</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">if</span> (isAncestorLoaderOf(loader, ploader)) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;926</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                loader = ploader; <span Class="comment">// pick more specific loader</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;927</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            } <span Class="keyword">else</span> {</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;928</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                <span Class="comment">// Either loader is a descendant of ploader or loaders are unrelated. Ignore both cases.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;929</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                <span Class="comment">// When loaders are not related, just pick one and proceed. It reduces the precision of keepsAlive, but</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;930</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                <span Class="comment">// doesn't compromise correctness.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;931</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;932</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;933</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;2/2&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> loader;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;934</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;935</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;936</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment"> Returns true when {@code loader} keeps components of {@code mt} reachable either directly or indirectly through the loader delegation chain. */</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;937</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">private</span> <span Class="keyword">static</span> <span Class="keyword">boolean</span> keepsAlive(MethodType mt, ClassLoader loader) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;938<a name="src_938"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;2/2&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">for</span> (Class&#60;?&#62; ptype : mt.ptypes()) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;939</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">if</span> (!keepsAlive(ptype, loader)) {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;940</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                <span Class="keyword">return</span> <span Class="keyword">false</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;941</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;942</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;943</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;2/2&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> keepsAlive(mt.rtype(), loader);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;944</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;945</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;946</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment"> Returns true when {@code loader} keeps {@code cls} either directly or indirectly through the loader delegation chain. */</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;947</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">private</span> <span Class="keyword">static</span> <span Class="keyword">boolean</span> keepsAlive(Class&#60;?&#62; cls, ClassLoader loader) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;948<a name="src_948"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        ClassLoader defLoader = cls.getClassLoader();</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;949</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (isBuiltinLoader(defLoader)) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;950</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">return</span> <span Class="keyword">true</span>; <span Class="comment">// built-in loaders are always reachable</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;951</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;952</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> isAncestorLoaderOf(defLoader, loader);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;953</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;954</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;955</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">private</span> <span Class="keyword">static</span> <span Class="keyword">boolean</span> isAncestorLoaderOf(ClassLoader ancestor, ClassLoader descendant) {</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;956</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="comment">// Assume built-in loaders are interchangeable and all custom loaders delegate to one of them.</span></pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;957<a name="src_957"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (isBuiltinLoader(ancestor)) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;958</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">return</span> <span Class="keyword">true</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;959</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;960</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="comment">// Climb up the descendant chain until a built-in loader is encountered.</span></pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;961</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;1/2&nbsp;Branch:&nbsp;1/2&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">for</span> (ClassLoader loader = descendant; !isBuiltinLoader(loader); loader = loader.getParent()) {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;962</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">if</span> (loader == ancestor) {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;963</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                <span Class="keyword">return</span> <span Class="keyword">true</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;964</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;965</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;966</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;2/2&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> <span Class="keyword">false</span>; <span Class="comment">// no direct relation between loaders is found</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;967</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;968</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;969</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">private</span> <span Class="keyword">static</span> <span Class="keyword">boolean</span> isBuiltinLoader(ClassLoader loader) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;970<a name="src_970"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;4/4&nbsp;Branch:&nbsp;4/4&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> loader == <span Class="keyword">null</span> ||</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;971</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;               loader == ClassLoaders.platformClassLoader() ||</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;972</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;               loader == ClassLoaders.appClassLoader();</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;973</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;974</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;975</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;976</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Makes an &#60;em&#62;array-spreading&#60;/em&#62; method handle, which accepts a trailing array argument</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;977</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * and spreads its elements as positional arguments.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;978</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The new method handle adapts, as its &#60;i&#62;target&#60;/i&#62;,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;979</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the current method handle.  The type of the adapter will be</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;980</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the same as the type of the target, except that the final</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;981</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@code arrayLength} parameters of the target's type are replaced</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;982</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * by a single array parameter of type {@code arrayType}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;983</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;984</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * If the array element type differs from any of the corresponding</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;985</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * argument types on the original target,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;986</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the original target is adapted to take the array elements directly,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;987</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * as if by a call to {@link #asType asType}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;988</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;989</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * When called, the adapter replaces a trailing array argument</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;990</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * by the array's elements, each as its own argument to the target.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;991</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * (The order of the arguments is preserved.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;992</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * They are converted pairwise by casting and/or unboxing</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;993</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * to the types of the trailing parameters of the target.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;994</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Finally the target is called.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;995</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * What the target eventually returns is returned unchanged by the adapter.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;996</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;997</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Before calling the target, the adapter verifies that the array</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;998</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * contains exactly enough elements to provide a correct argument count</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;999</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * to the target method handle.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1000</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * (The array may also be null when zero elements are required.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1001</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1002</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * When the adapter is called, the length of the supplied {@code array}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1003</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * argument is queried as if by {@code array.length} or {@code arraylength}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1004</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * bytecode. If the adapter accepts a zero-length trailing array argument,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1005</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the supplied {@code array} argument can either be a zero-length array or</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1006</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@code null}; otherwise, the adapter will throw a {@code NullPointerException}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1007</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * if the array is {@code null} and throw an {@link IllegalArgumentException}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1008</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * if the array does not have the correct number of elements.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1009</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1010</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Here are some simple examples of array-spreading method handles:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1011</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@snippet lang="java" :</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1012</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle equals = publicLookup()</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1013</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">  .findVirtual(String.class, "equals", methodType(boolean.class, Object.class));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1014</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assert( (boolean) equals.invokeExact("me", (Object)"me"));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1015</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assert(!(boolean) equals.invokeExact("me", (Object)"thee"));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1016</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// spread both arguments from a 2-array:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1017</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle eq2 = equals.asSpreader(Object[].class, 2);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1018</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assert( (boolean) eq2.invokeExact(new Object[]{ "me", "me" }));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1019</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assert(!(boolean) eq2.invokeExact(new Object[]{ "me", "thee" }));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1020</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// try to spread from anything but a 2-array:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1021</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">for (int n = 0; n &#60;= 10; n++) {</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1022</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">  Object[] badArityArgs = (n == 2 ? new Object[0] : new Object[n]);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1023</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">  try { assert((boolean) eq2.invokeExact(badArityArgs) &#38;&#38; false); }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1024</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">  catch (IllegalArgumentException ex) { } // OK</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1025</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1026</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// spread both arguments from a String array:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1027</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle eq2s = equals.asSpreader(String[].class, 2);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1028</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assert( (boolean) eq2s.invokeExact(new String[]{ "me", "me" }));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1029</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assert(!(boolean) eq2s.invokeExact(new String[]{ "me", "thee" }));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1030</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// spread second arguments from a 1-array:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1031</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle eq1 = equals.asSpreader(Object[].class, 1);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1032</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assert( (boolean) eq1.invokeExact("me", new Object[]{ "me" }));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1033</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assert(!(boolean) eq1.invokeExact("me", new Object[]{ "thee" }));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1034</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// spread no arguments from a 0-array or null:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1035</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle eq0 = equals.asSpreader(Object[].class, 0);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1036</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assert( (boolean) eq0.invokeExact("me", (Object)"me", new Object[0]));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1037</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assert(!(boolean) eq0.invokeExact("me", (Object)"thee", (Object[])null));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1038</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// asSpreader and asCollector are approximate inverses:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1039</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">for (int n = 0; n &#60;= 2; n++) {</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1040</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">    for (Class&#60;?&#62; a : new Class&#60;?&#62;[]{Object[].class, String[].class, CharSequence[].class}) {</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1041</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">        MethodHandle equals2 = equals.asSpreader(a, n).asCollector(a, n);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1042</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">        assert( (boolean) equals2.invokeWithArguments("me", "me"));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1043</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">        assert(!(boolean) equals2.invokeWithArguments("me", "thee"));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1044</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">    }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1045</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1046</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle caToString = publicLookup()</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1047</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">  .findStatic(Arrays.class, "toString", methodType(String.class, char[].class));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1048</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[A, B, C]", (String) caToString.invokeExact("ABC".toCharArray()));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1049</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle caString3 = caToString.asCollector(char[].class, 3);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1050</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[A, B, C]", (String) caString3.invokeExact('A', 'B', 'C'));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1051</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle caToString2 = caString3.asSpreader(char[].class, 2);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1052</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[A, B, C]", (String) caToString2.invokeExact('A', "BC".toCharArray()));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1053</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1054</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param arrayType usually {@code Object[]}, the type of the array argument from which to extract the spread arguments</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1055</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param arrayLength the number of arguments to spread from an incoming array argument</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1056</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return a new method handle which spreads its final array argument,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1057</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         before calling the original method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1058</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws NullPointerException if {@code arrayType} is a null reference</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1059</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws IllegalArgumentException if {@code arrayType} is not an array type,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1060</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         or if target does not have at least</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1061</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         {@code arrayLength} parameter types,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1062</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         or if {@code arrayLength} is negative,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1063</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         or if the resulting method handle's type would have</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1064</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         &#60;a href="MethodHandle.html#maxarity"&#62;too many parameters&#60;/a&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1065</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws WrongMethodTypeException if the implied {@code asType} call fails</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1066</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see #asCollector</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1067</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1068</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">public</span> MethodHandle asSpreader(Class&#60;?&#62; arrayType, <span Class="keyword">int</span> arrayLength) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1069<a name="src_1069"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> asSpreader(type().parameterCount() - arrayLength, arrayType, arrayLength);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1070</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1071</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1072</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1073</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Makes an &#60;em&#62;array-spreading&#60;/em&#62; method handle, which accepts an array argument at a given position and spreads</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1074</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * its elements as positional arguments in place of the array. The new method handle adapts, as its &#60;i&#62;target&#60;/i&#62;,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1075</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the current method handle. The type of the adapter will be the same as the type of the target, except that the</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1076</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@code arrayLength} parameters of the target's type, starting at the zero-based position {@code spreadArgPos},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1077</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * are replaced by a single array parameter of type {@code arrayType}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1078</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1079</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * This method behaves very much like {@link #asSpreader(Class, int)}, but accepts an additional {@code spreadArgPos}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1080</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * argument to indicate at which position in the parameter list the spreading should take place.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1081</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1082</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @apiNote Example:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1083</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@snippet lang="java" :</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1084</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">    MethodHandle compare = LOOKUP.findStatic(Objects.class, "compare", methodType(int.class, Object.class, Object.class, Comparator.class));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1085</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">    MethodHandle compare2FromArray = compare.asSpreader(0, Object[].class, 2);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1086</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">    Object[] ints = new Object[]{3, 9, 7, 7};</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1087</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">    Comparator&#60;Integer&#62; cmp = (a, b) -&#62; a - b;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1088</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">    assertTrue((int) compare2FromArray.invoke(Arrays.copyOfRange(ints, 0, 2), cmp) &#60; 0);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1089</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">    assertTrue((int) compare2FromArray.invoke(Arrays.copyOfRange(ints, 1, 3), cmp) &#62; 0);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1090</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">    assertTrue((int) compare2FromArray.invoke(Arrays.copyOfRange(ints, 2, 4), cmp) == 0);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1091</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1092</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param spreadArgPos the position (zero-based index) in the argument list at which spreading should start.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1093</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param arrayType usually {@code Object[]}, the type of the array argument from which to extract the spread arguments</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1094</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param arrayLength the number of arguments to spread from an incoming array argument</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1095</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return a new method handle which spreads an array argument at a given position,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1096</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         before calling the original method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1097</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws NullPointerException if {@code arrayType} is a null reference</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1098</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws IllegalArgumentException if {@code arrayType} is not an array type,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1099</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         or if target does not have at least</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1100</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         {@code arrayLength} parameter types,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1101</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         or if {@code arrayLength} is negative,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1102</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         or if {@code spreadArgPos} has an illegal value (negative, or together with arrayLength exceeding the</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1103</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         number of arguments),</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1104</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         or if the resulting method handle's type would have</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1105</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         &#60;a href="MethodHandle.html#maxarity"&#62;too many parameters&#60;/a&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1106</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws WrongMethodTypeException if the implied {@code asType} call fails</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1107</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1108</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see #asSpreader(Class, int)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1109</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @since 9</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1110</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1111</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">public</span> MethodHandle asSpreader(<span Class="keyword">int</span> spreadArgPos, Class&#60;?&#62; arrayType, <span Class="keyword">int</span> arrayLength) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1112<a name="src_1112"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        MethodType postSpreadType = asSpreaderChecks(arrayType, spreadArgPos, arrayLength);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1113</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        MethodHandle afterSpread = <span Class="keyword">this</span>.asType(postSpreadType);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1114</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        BoundMethodHandle mh = afterSpread.rebind();</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1115</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        LambdaForm lform = mh.editor().spreadArgumentsForm(1 + spreadArgPos, arrayType, arrayLength);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1116</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        MethodType preSpreadType = postSpreadType.replaceParameterTypes(spreadArgPos, spreadArgPos + arrayLength, arrayType);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1117</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> mh.copyWith(preSpreadType, lform);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1118</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1119</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1120</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1121</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * See if {@code asSpreader} can be validly called with the given arguments.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1122</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Return the type of the method handle call after spreading but before conversions.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1123</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1124</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">private</span> MethodType asSpreaderChecks(Class&#60;?&#62; arrayType, <span Class="keyword">int</span> pos, <span Class="keyword">int</span> arrayLength) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1125<a name="src_1125"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        spreadArrayChecks(arrayType, arrayLength);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1126</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">int</span> nargs = type().parameterCount();</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1127</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (nargs &#60; arrayLength || arrayLength &#60; 0)</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1128</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/2&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">throw</span> newIllegalArgumentException(<span Class="string">"bad spread array length"</span>);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1129</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (pos &#60; 0 || pos + arrayLength &#62; nargs) {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1130</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/2&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">throw</span> newIllegalArgumentException(<span Class="string">"bad spread position"</span>);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1131</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1132</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        Class&#60;?&#62; arrayElement = arrayType.getComponentType();</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1133</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        MethodType mtype = type();</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1134</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">boolean</span> match = <span Class="keyword">true</span>, fail = <span Class="keyword">false</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1135</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/2&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">for</span> (<span Class="keyword">int</span> i = pos; i &#60; pos + arrayLength; i++) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1136</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            Class&#60;?&#62; ptype = mtype.parameterType(i);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1137</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">if</span> (ptype != arrayElement) {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1138</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                match = <span Class="keyword">false</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1139</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                <span Class="keyword">if</span> (!MethodType.canConvert(arrayElement, ptype)) {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1140</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                    fail = <span Class="keyword">true</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1141</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                    <span Class="keyword">break</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1142</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1143</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1144</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1145</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (match)  <span Class="keyword">return</span> mtype;</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1146</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        MethodType needType = mtype.asSpreaderType(arrayType, pos, arrayLength);</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1147</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (!fail)  <span Class="keyword">return</span> needType;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1148</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="comment">// elicit an error:</span></pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1149</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">this</span>.asType(needType);</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1150</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;4/5&nbsp;Branch:&nbsp;3/4&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">throw</span> newInternalError(<span Class="string">"should not return"</span>);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1151</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1152</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1153</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">private</span> <span Class="keyword">void</span> spreadArrayChecks(Class&#60;?&#62; arrayType, <span Class="keyword">int</span> arrayLength) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1154<a name="src_1154"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        Class&#60;?&#62; arrayElement = arrayType.getComponentType();</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1155</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (arrayElement == <span Class="keyword">null</span>)</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1156</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">throw</span> newIllegalArgumentException(<span Class="string">"not an array type"</span>, arrayType);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1157</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> ((arrayLength &#38; 0x7F) != arrayLength) {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1158</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">if</span> ((arrayLength &#38; 0xFF) != arrayLength)</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1159</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                <span Class="keyword">throw</span> newIllegalArgumentException(<span Class="string">"array length is not legal"</span>, arrayLength);</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1160</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">assert</span>(arrayLength &#62;= 128);</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1161</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/2&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">if</span> (arrayElement == <span Class="keyword">long</span>.<span Class="keyword">class</span> ||</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1162</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                arrayElement == <span Class="keyword">double</span>.<span Class="keyword">class</span>)</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1163</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/2&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                <span Class="keyword">throw</span> newIllegalArgumentException(<span Class="string">"array length is not legal for long[] or double[]"</span>, arrayLength);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1164</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1165</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;1/4&nbsp;Branch:&nbsp;1/5&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1166</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1167</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1168</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Adapts this method handle to be {@linkplain #asVarargsCollector variable arity}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1169</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * if the boolean flag is true, else {@linkplain #asFixedArity fixed arity}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1170</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * If the method handle is already of the proper arity mode, it is returned</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1171</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * unchanged.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1172</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @apiNote</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1173</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;This method is sometimes useful when adapting a method handle that</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1174</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * may be variable arity, to ensure that the resulting adapter is also</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1175</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * variable arity if and only if the original handle was.  For example,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1176</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * this code changes the first argument of a handle {@code mh} to {@code int} without</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1177</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * disturbing its variable arity property:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1178</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@code mh.asType(mh.type().changeParameterType(0,int.class))</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1179</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     .withVarargs(mh.isVarargsCollector())}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1180</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1181</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * This call is approximately equivalent to the following code:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1182</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@snippet lang="java" :</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1183</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * if (makeVarargs == isVarargsCollector())</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1184</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *   return this;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1185</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * else if (makeVarargs)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1186</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *   return asVarargsCollector(type().lastParameterType());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1187</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * else</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1188</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *   return asFixedArity();</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1189</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1190</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param makeVarargs true if the return method handle should have variable arity behavior</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1191</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return a method handle of the same type, with possibly adjusted variable arity behavior</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1192</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws IllegalArgumentException if {@code makeVarargs} is true and</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1193</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         this method handle does not have a trailing array parameter</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1194</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @since 9</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1195</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see #asVarargsCollector</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1196</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see #asFixedArity</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1197</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1198</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">public</span> MethodHandle withVarargs(<span Class="keyword">boolean</span> makeVarargs) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1199<a name="src_1199"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">assert</span>(!isVarargsCollector());  <span Class="comment">// subclass responsibility</span></pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1200</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;2/2&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (makeVarargs) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1201</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;           <span Class="keyword">return</span> asVarargsCollector(type().lastParameterType());</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1202</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        } <span Class="keyword">else</span> {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1203</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;1/3&nbsp;Branch:&nbsp;1/3&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">return</span> <span Class="keyword">this</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1204</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1205</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1206</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1207</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1208</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Makes an &#60;em&#62;array-collecting&#60;/em&#62; method handle, which accepts a given number of trailing</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1209</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * positional arguments and collects them into an array argument.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1210</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The new method handle adapts, as its &#60;i&#62;target&#60;/i&#62;,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1211</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the current method handle.  The type of the adapter will be</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1212</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the same as the type of the target, except that a single trailing</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1213</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * parameter (usually of type {@code arrayType}) is replaced by</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1214</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@code arrayLength} parameters whose type is element type of {@code arrayType}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1215</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1216</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * If the array type differs from the final argument type on the original target,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1217</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the original target is adapted to take the array type directly,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1218</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * as if by a call to {@link #asType asType}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1219</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1220</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * When called, the adapter replaces its trailing {@code arrayLength}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1221</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * arguments by a single new array of type {@code arrayType}, whose elements</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1222</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * comprise (in order) the replaced arguments.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1223</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Finally the target is called.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1224</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * What the target eventually returns is returned unchanged by the adapter.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1225</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1226</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * (The array may also be a shared constant when {@code arrayLength} is zero.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1227</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1228</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * (&#60;em&#62;Note:&#60;/em&#62; The {@code arrayType} is often identical to the</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1229</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@linkplain MethodType#lastParameterType last parameter type}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1230</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * of the original target.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1231</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * It is an explicit argument for symmetry with {@code asSpreader}, and also</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1232</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * to allow the target to use a simple {@code Object} as its last parameter type.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1233</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1234</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * In order to create a collecting adapter which is not restricted to a particular</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1235</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * number of collected arguments, use {@link #asVarargsCollector asVarargsCollector}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1236</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * or {@link #withVarargs withVarargs} instead.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1237</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1238</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Here are some examples of array-collecting method handles:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1239</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@snippet lang="java" :</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1240</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle deepToString = publicLookup()</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1241</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">  .findStatic(Arrays.class, "deepToString", methodType(String.class, Object[].class));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1242</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[won]",   (String) deepToString.invokeExact(new Object[]{"won"}));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1243</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle ts1 = deepToString.asCollector(Object[].class, 1);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1244</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals(methodType(String.class, Object.class), ts1.type());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1245</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">//assertEquals("[won]", (String) ts1.invokeExact(         new Object[]{"won"})); //FAIL</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1246</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[[won]]", (String) ts1.invokeExact((Object) new Object[]{"won"}));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1247</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// arrayType can be a subtype of Object[]</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1248</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle ts2 = deepToString.asCollector(String[].class, 2);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1249</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals(methodType(String.class, String.class, String.class), ts2.type());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1250</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[two, too]", (String) ts2.invokeExact("two", "too"));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1251</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle ts0 = deepToString.asCollector(Object[].class, 0);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1252</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[]", (String) ts0.invokeExact());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1253</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// collectors can be nested, Lisp-style</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1254</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle ts22 = deepToString.asCollector(Object[].class, 3).asCollector(String[].class, 2);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1255</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[A, B, [C, D]]", ((String) ts22.invokeExact((Object)'A', (Object)"B", "C", "D")));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1256</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// arrayType can be any primitive array type</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1257</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle bytesToString = publicLookup()</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1258</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">  .findStatic(Arrays.class, "toString", methodType(String.class, byte[].class))</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1259</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">  .asCollector(byte[].class, 3);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1260</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[1, 2, 3]", (String) bytesToString.invokeExact((byte)1, (byte)2, (byte)3));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1261</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle longsToString = publicLookup()</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1262</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">  .findStatic(Arrays.class, "toString", methodType(String.class, long[].class))</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1263</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">  .asCollector(long[].class, 1);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1264</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[123]", (String) longsToString.invokeExact((long)123));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1265</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1266</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1267</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;em&#62;Note:&#60;/em&#62; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1268</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * variable-arity method handle}, even if the original target method handle was.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1269</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param arrayType often {@code Object[]}, the type of the array argument which will collect the arguments</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1270</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param arrayLength the number of arguments to collect into a new array argument</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1271</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return a new method handle which collects some trailing argument</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1272</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         into an array, before calling the original method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1273</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws NullPointerException if {@code arrayType} is a null reference</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1274</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws IllegalArgumentException if {@code arrayType} is not an array type</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1275</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         or {@code arrayType} is not assignable to this method handle's trailing parameter type,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1276</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         or {@code arrayLength} is not a legal array size,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1277</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         or the resulting method handle's type would have</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1278</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         &#60;a href="MethodHandle.html#maxarity"&#62;too many parameters&#60;/a&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1279</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws WrongMethodTypeException if the implied {@code asType} call fails</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1280</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see #asSpreader</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1281</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see #asVarargsCollector</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1282</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1283</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">public</span> MethodHandle asCollector(Class&#60;?&#62; arrayType, <span Class="keyword">int</span> arrayLength) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1284<a name="src_1284"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> asCollector(type().parameterCount() - 1, arrayType, arrayLength);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1285</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1286</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1287</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1288</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Makes an &#60;em&#62;array-collecting&#60;/em&#62; method handle, which accepts a given number of positional arguments starting</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1289</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * at a given position, and collects them into an array argument. The new method handle adapts, as its</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1290</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;i&#62;target&#60;/i&#62;, the current method handle. The type of the adapter will be the same as the type of the target,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1291</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * except that the parameter at the position indicated by {@code collectArgPos} (usually of type {@code arrayType})</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1292</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * is replaced by {@code arrayLength} parameters whose type is element type of {@code arrayType}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1293</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1294</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * This method behaves very much like {@link #asCollector(Class, int)}, but differs in that its {@code</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1295</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * collectArgPos} argument indicates at which position in the parameter list arguments should be collected. This</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1296</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * index is zero-based.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1297</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1298</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @apiNote Examples:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1299</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@snippet lang="java" :</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1300</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">    StringWriter swr = new StringWriter();</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1301</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">    MethodHandle swWrite = LOOKUP.findVirtual(StringWriter.class, "write", methodType(void.class, char[].class, int.class, int.class)).bindTo(swr);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1302</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">    MethodHandle swWrite4 = swWrite.asCollector(0, char[].class, 4);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1303</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">    swWrite4.invoke('A', 'B', 'C', 'D', 1, 2);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1304</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">    assertEquals("BC", swr.toString());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1305</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">    swWrite4.invoke('P', 'Q', 'R', 'S', 0, 4);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1306</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">    assertEquals("BCPQRS", swr.toString());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1307</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">    swWrite4.invoke('W', 'X', 'Y', 'Z', 3, 1);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1308</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">    assertEquals("BCPQRSZ", swr.toString());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1309</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1310</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1311</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;em&#62;Note:&#60;/em&#62; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1312</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * variable-arity method handle}, even if the original target method handle was.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1313</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param collectArgPos the zero-based position in the parameter list at which to start collecting.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1314</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param arrayType often {@code Object[]}, the type of the array argument which will collect the arguments</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1315</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param arrayLength the number of arguments to collect into a new array argument</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1316</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return a new method handle which collects some arguments</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1317</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         into an array, before calling the original method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1318</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws NullPointerException if {@code arrayType} is a null reference</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1319</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws IllegalArgumentException if {@code arrayType} is not an array type</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1320</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         or {@code arrayType} is not assignable to this method handle's array parameter type,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1321</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         or {@code arrayLength} is not a legal array size,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1322</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         or {@code collectArgPos} has an illegal value (negative, or greater than the number of arguments),</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1323</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         or the resulting method handle's type would have</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1324</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         &#60;a href="MethodHandle.html#maxarity"&#62;too many parameters&#60;/a&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1325</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws WrongMethodTypeException if the implied {@code asType} call fails</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1326</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1327</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see #asCollector(Class, int)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1328</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @since 9</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1329</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1330</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">public</span> MethodHandle asCollector(<span Class="keyword">int</span> collectArgPos, Class&#60;?&#62; arrayType, <span Class="keyword">int</span> arrayLength) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1331<a name="src_1331"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        asCollectorChecks(arrayType, collectArgPos, arrayLength);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1332</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        BoundMethodHandle mh = rebind();</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1333</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        MethodType resultType = type().asCollectorType(arrayType, collectArgPos, arrayLength);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1334</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        MethodHandle collector = MethodHandleImpl.varargsArray(arrayType, arrayLength);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1335</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        LambdaForm lform = mh.editor().collectArgumentsForm(1 + collectArgPos, collector.type().basicType());</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1336</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> mh.copyWithExtendL(resultType, lform, collector);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1337</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1338</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1339</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1340</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * See if {@code asCollector} can be validly called with the given arguments.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1341</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Return false if the last parameter is not an exact match to arrayType.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1342</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1343</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1344</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">boolean</span> asCollectorChecks(Class&#60;?&#62; arrayType, <span Class="keyword">int</span> pos, <span Class="keyword">int</span> arrayLength) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1345<a name="src_1345"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        spreadArrayChecks(arrayType, arrayLength);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1346</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">int</span> nargs = type().parameterCount();</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1347</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (pos &#60; 0 || pos &#62;= nargs) {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1348</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/2&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">throw</span> newIllegalArgumentException(<span Class="string">"bad collect position"</span>);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1349</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1350</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (nargs != 0) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1351</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            Class&#60;?&#62; param = type().parameterType(pos);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1352</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">if</span> (param == arrayType)  <span Class="keyword">return</span> <span Class="keyword">true</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1353</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">if</span> (param.isAssignableFrom(arrayType))  <span Class="keyword">return</span> <span Class="keyword">false</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1354</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1355</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;2/4&nbsp;Branch:&nbsp;2/5&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">throw</span> newIllegalArgumentException(<span Class="string">"array type not assignable to argument"</span>, <span Class="keyword">this</span>, arrayType);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1356</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1357</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1358</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1359</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Makes a &#60;em&#62;variable arity&#60;/em&#62; adapter which is able to accept</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1360</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * any number of trailing positional arguments and collect them</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1361</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * into an array argument.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1362</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1363</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The type and behavior of the adapter will be the same as</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1364</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the type and behavior of the target, except that certain</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1365</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@code invoke} and {@code asType} requests can lead to</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1366</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * trailing positional arguments being collected into target's</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1367</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * trailing parameter.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1368</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Also, the</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1369</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@linkplain MethodType#lastParameterType last parameter type}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1370</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * of the adapter will be</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1371</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@code arrayType}, even if the target has a different</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1372</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * last parameter type.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1373</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1374</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * This transformation may return {@code this} if the method handle is</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1375</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * already of variable arity and its trailing parameter type</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1376</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * is identical to {@code arrayType}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1377</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1378</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * When called with {@link #invokeExact invokeExact}, the adapter invokes</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1379</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the target with no argument changes.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1380</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * (&#60;em&#62;Note:&#60;/em&#62; This behavior is different from a</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1381</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@linkplain #asCollector fixed arity collector},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1382</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * since it accepts a whole array of indeterminate length,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1383</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * rather than a fixed number of arguments.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1384</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1385</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * When called with plain, inexact {@link #invoke invoke}, if the caller</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1386</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * type is the same as the adapter, the adapter invokes the target as with</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1387</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@code invokeExact}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1388</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * (This is the normal behavior for {@code invoke} when types match.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1389</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1390</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Otherwise, if the caller and adapter arity are the same, and the</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1391</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * trailing parameter type of the caller is a reference type identical to</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1392</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * or assignable to the trailing parameter type of the adapter,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1393</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the arguments and return values are converted pairwise,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1394</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * as if by {@link #asType asType} on a fixed arity</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1395</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * method handle.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1396</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1397</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Otherwise, the arities differ, or the adapter's trailing parameter</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1398</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * type is not assignable from the corresponding caller type.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1399</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * In this case, the adapter replaces all trailing arguments from</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1400</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the original trailing argument position onward, by</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1401</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * a new array of type {@code arrayType}, whose elements</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1402</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * comprise (in order) the replaced arguments.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1403</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1404</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The caller type must provide at least enough arguments,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1405</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * and of the correct type, to satisfy the target's requirement for</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1406</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * positional arguments before the trailing array argument.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1407</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Thus, the caller must supply, at a minimum, {@code N-1} arguments,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1408</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * where {@code N} is the arity of the target.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1409</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Also, there must exist conversions from the incoming arguments</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1410</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * to the target's arguments.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1411</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * As with other uses of plain {@code invoke}, if these basic</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1412</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * requirements are not fulfilled, a {@code WrongMethodTypeException}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1413</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * may be thrown.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1414</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1415</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * In all cases, what the target eventually returns is returned unchanged by the adapter.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1416</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1417</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * In the final case, it is exactly as if the target method handle were</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1418</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * temporarily adapted with a {@linkplain #asCollector fixed arity collector}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1419</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * to the arity required by the caller type.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1420</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * (As with {@code asCollector}, if the array length is zero,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1421</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * a shared constant may be used instead of a new array.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1422</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * If the implied call to {@code asCollector} would throw</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1423</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * an {@code IllegalArgumentException} or {@code WrongMethodTypeException},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1424</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the call to the variable arity adapter must throw</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1425</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@code WrongMethodTypeException}.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1426</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1427</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The behavior of {@link #asType asType} is also specialized for</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1428</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * variable arity adapters, to maintain the invariant that</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1429</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * plain, inexact {@code invoke} is always equivalent to an {@code asType}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1430</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * call to adjust the target type, followed by {@code invokeExact}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1431</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Therefore, a variable arity adapter responds</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1432</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * to an {@code asType} request by building a fixed arity collector,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1433</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * if and only if the adapter and requested type differ either</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1434</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * in arity or trailing argument type.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1435</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The resulting fixed arity collector has its type further adjusted</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1436</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * (if necessary) to the requested type by pairwise conversion,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1437</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * as if by another application of {@code asType}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1438</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1439</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * When a method handle is obtained by executing an {@code ldc} instruction</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1440</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * of a {@code CONSTANT_MethodHandle} constant, and the target method is marked</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1441</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * as a variable arity method (with the modifier bit {@code 0x0080}),</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1442</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the method handle will accept multiple arities, as if the method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1443</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * constant were created by means of a call to {@code asVarargsCollector}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1444</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1445</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * In order to create a collecting adapter which collects a predetermined</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1446</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * number of arguments, and whose type reflects this predetermined number,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1447</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * use {@link #asCollector asCollector} instead.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1448</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1449</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * No method handle transformations produce new method handles with</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1450</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * variable arity, unless they are documented as doing so.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1451</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Therefore, besides {@code asVarargsCollector} and {@code withVarargs},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1452</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * all methods in {@code MethodHandle} and {@code MethodHandles}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1453</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * will return a method handle with fixed arity,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1454</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * except in the cases where they are specified to return their original</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1455</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * operand (e.g., {@code asType} of the method handle's own type).</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1456</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1457</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Calling {@code asVarargsCollector} on a method handle which is already</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1458</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * of variable arity will produce a method handle with the same type and behavior.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1459</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * It may (or may not) return the original variable arity method handle.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1460</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1461</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Here is an example, of a list-making variable arity method handle:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1462</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@snippet lang="java" :</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1463</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle deepToString = publicLookup()</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1464</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">  .findStatic(Arrays.class, "deepToString", methodType(String.class, Object[].class));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1465</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle ts1 = deepToString.asVarargsCollector(Object[].class);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1466</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[won]",   (String) ts1.invokeExact(    new Object[]{"won"}));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1467</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[won]",   (String) ts1.invoke(         new Object[]{"won"}));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1468</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[won]",   (String) ts1.invoke(                      "won" ));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1469</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[[won]]", (String) ts1.invoke((Object) new Object[]{"won"}));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1470</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">// findStatic of Arrays.asList(...) produces a variable arity method handle:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1471</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle asList = publicLookup()</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1472</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">  .findStatic(Arrays.class, "asList", methodType(List.class, Object[].class));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1473</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals(methodType(List.class, Object[].class), asList.type());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1474</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assert(asList.isVarargsCollector());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1475</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[]", asList.invoke().toString());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1476</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[1]", asList.invoke(1).toString());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1477</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[two, too]", asList.invoke("two", "too").toString());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1478</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">String[] argv = { "three", "thee", "tee" };</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1479</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[three, thee, tee]", asList.invoke(argv).toString());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1480</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[three, thee, tee]", asList.invoke((Object[])argv).toString());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1481</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">List ls = (List) asList.invoke((Object)argv);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1482</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals(1, ls.size());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1483</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[three, thee, tee]", Arrays.toString((Object[])ls.get(0)));</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1484</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1485</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p style="font-size:smaller;"&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1486</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;em&#62;Discussion:&#60;/em&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1487</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * These rules are designed as a dynamically-typed variation</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1488</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * of the Java rules for variable arity methods.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1489</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * In both cases, callers to a variable arity method or method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1490</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * can either pass zero or more positional arguments, or else pass</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1491</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * pre-collected arrays of any length.  Users should be aware of the</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1492</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * special role of the final argument, and of the effect of a</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1493</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * type match on that final argument, which determines whether</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1494</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * or not a single trailing argument is interpreted as a whole</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1495</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * array or a single element of an array to be collected.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1496</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Note that the dynamic type of the trailing argument has no</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1497</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * effect on this decision, only a comparison between the symbolic</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1498</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * type descriptor of the call site and the type descriptor of the method handle.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1499</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1500</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param arrayType often {@code Object[]}, the type of the array argument which will collect the arguments</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1501</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return a new method handle which can collect any number of trailing arguments</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1502</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         into an array, before calling the original method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1503</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws NullPointerException if {@code arrayType} is a null reference</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1504</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws IllegalArgumentException if {@code arrayType} is not an array type</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1505</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         or {@code arrayType} is not assignable to this method handle's trailing parameter type</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1506</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see #asCollector</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1507</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see #isVarargsCollector</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1508</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see #withVarargs</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1509</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see #asFixedArity</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1510</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1511</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">public</span> MethodHandle asVarargsCollector(Class&#60;?&#62; arrayType) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1512<a name="src_1512"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        Objects.requireNonNull(arrayType);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1513</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">boolean</span> lastMatch = asCollectorChecks(arrayType, type().parameterCount() - 1, 0);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1514</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (isVarargsCollector() &#38;&#38; lastMatch)</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1515</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">return</span> <span Class="keyword">this</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1516</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;1/2&nbsp;Branch:&nbsp;1/3&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> MethodHandleImpl.makeVarargsCollector(<span Class="keyword">this</span>, arrayType);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1517</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1518</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1519</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1520</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Determines if this method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1521</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * supports {@linkplain #asVarargsCollector variable arity} calls.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1522</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Such method handles arise from the following sources:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1523</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;ul&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1524</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;a call to {@linkplain #asVarargsCollector asVarargsCollector}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1525</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;a call to a {@linkplain java.lang.invoke.MethodHandles.Lookup lookup method}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1526</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     which resolves to a variable arity Java method or constructor</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1527</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;li&#62;an {@code ldc} instruction of a {@code CONSTANT_MethodHandle}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1528</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *     which resolves to a variable arity Java method or constructor</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1529</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;/ul&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1530</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return true if this method handle accepts more than one arity of plain, inexact {@code invoke} calls</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1531</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see #asVarargsCollector</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1532</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see #asFixedArity</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1533</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1534</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">public</span> <span Class="keyword">boolean</span> isVarargsCollector() {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1535<a name="src_1535"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> <span Class="keyword">false</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1536</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1537</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1538</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1539</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Makes a &#60;em&#62;fixed arity&#60;/em&#62; method handle which is otherwise</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1540</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * equivalent to the current method handle.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1541</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1542</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * If the current method handle is not of</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1543</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@linkplain #asVarargsCollector variable arity},</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1544</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the current method handle is returned.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1545</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * This is true even if the current method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1546</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * could not be a valid input to {@code asVarargsCollector}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1547</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1548</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Otherwise, the resulting fixed-arity method handle has the same</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1549</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * type and behavior of the current method handle,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1550</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * except that {@link #isVarargsCollector isVarargsCollector}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1551</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * will be false.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1552</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The fixed-arity method handle may (or may not) be the</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1553</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * previous argument to {@code asVarargsCollector}.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1554</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1555</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Here is an example, of a list-making variable arity method handle:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1556</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@snippet lang="java" :</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1557</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle asListVar = publicLookup()</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1558</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">  .findStatic(Arrays.class, "asList", methodType(List.class, Object[].class))</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1559</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">  .asVarargsCollector(Object[].class);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1560</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">MethodHandle asListFix = asListVar.asFixedArity();</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1561</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[1]", asListVar.invoke(1).toString());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1562</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">Exception caught = null;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1563</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">try { asListFix.invoke((Object)1); }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1564</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">catch (Exception ex) { caught = ex; }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1565</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assert(caught instanceof ClassCastException);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1566</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[two, too]", asListVar.invoke("two", "too").toString());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1567</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">try { asListFix.invoke("two", "too"); }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1568</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">catch (Exception ex) { caught = ex; }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1569</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assert(caught instanceof WrongMethodTypeException);</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1570</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">Object[] argv = { "three", "thee", "tee" };</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1571</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[three, thee, tee]", asListVar.invoke(argv).toString());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1572</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[three, thee, tee]", asListFix.invoke(argv).toString());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1573</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals(1, ((List) asListVar.invoke((Object)argv)).size());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1574</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">assertEquals("[three, thee, tee]", asListFix.invoke((Object)argv).toString());</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1575</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1576</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1577</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return a new method handle which accepts only a fixed number of arguments</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1578</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see #asVarargsCollector</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1579</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see #isVarargsCollector</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1580</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see #withVarargs</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1581</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1582</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">public</span> MethodHandle asFixedArity() {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1583<a name="src_1583"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">assert</span>(!isVarargsCollector());</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1584</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;2/3&nbsp;Branch:&nbsp;3/4&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> <span Class="keyword">this</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1585</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1586</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1587</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1588</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Binds a value {@code x} to the first argument of a method handle, without invoking it.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1589</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The new method handle adapts, as its &#60;i&#62;target&#60;/i&#62;,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1590</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the current method handle by binding it to the given argument.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1591</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The type of the bound handle will be</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1592</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * the same as the type of the target, except that a single leading</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1593</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * reference parameter will be omitted.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1594</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1595</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * When called, the bound handle inserts the given value {@code x}</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1596</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * as a new leading argument to the target.  The other arguments are</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1597</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * also passed unchanged.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1598</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * What the target eventually returns is returned unchanged by the bound handle.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1599</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1600</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The reference {@code x} must be convertible to the first parameter</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1601</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * type of the target.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1602</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1603</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;em&#62;Note:&#60;/em&#62;  Because method handles are immutable, the target method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1604</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * retains its original type and behavior.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1605</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1606</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;em&#62;Note:&#60;/em&#62; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1607</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * variable-arity method handle}, even if the original target method handle was.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1608</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @param x  the value to bind to the first argument of the target</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1609</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return a new method handle which prepends the given value to the incoming</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1610</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         argument list, before calling the original method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1611</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws IllegalArgumentException if the target does not have a</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1612</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         leading parameter type that is a reference type</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1613</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @throws ClassCastException if {@code x} cannot be converted</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1614</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *         to the leading parameter type of the target</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1615</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @see MethodHandles#insertArguments</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1616</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1617</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">public</span> MethodHandle bindTo(Object x) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1618<a name="src_1618"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        x = type.leadingReferenceParameter().cast(x);  <span Class="comment">// throw CCE if needed</span></pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1619</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> bindArgumentL(0, x);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1620</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1621</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1622</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1623</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Return a nominal descriptor for this instance, if one can be</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1624</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * constructed, or an empty {@link Optional} if one cannot be.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1625</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1626</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return An {@link Optional} containing the resulting nominal descriptor,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1627</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * or an empty {@link Optional} if one cannot be constructed.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1628</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @since 12</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1629</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1630</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    @Override</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1631</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">public</span> Optional&#60;MethodHandleDesc&#62; describeConstable() {</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1632</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        MethodHandleInfo info;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1633</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        ClassDesc owner;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1634</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        String name;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1635</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        MethodTypeDesc type;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1636</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">boolean</span> isInterface;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1637</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">try</span> {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1638<a name="src_1638"></a></td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            info = IMPL_LOOKUP.revealDirect(<span Class="keyword">this</span>);</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1639</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            isInterface = info.getDeclaringClass().isInterface();</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1640</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            owner = info.getDeclaringClass().describeConstable().orElseThrow();</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1641</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            type = info.getMethodType().describeConstable().orElseThrow();</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1642</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            name = info.getName();</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1643</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1644</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">catch</span> (Exception e) {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1645</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">return</span> Optional.empty();</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1646</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1647</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1648</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/2&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> <span Class="keyword">switch</span> (info.getReferenceKind()) {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1649</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">case</span> REF_getField         -&#62; Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.GETTER, owner, name, type.returnType()));</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1650</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">case</span> REF_putField         -&#62; Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.SETTER, owner, name, type.parameterType(0)));</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1651</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">case</span> REF_getStatic        -&#62; Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_GETTER, owner, name, type.returnType()));</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1652</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">case</span> REF_putStatic        -&#62; Optional.of(MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_SETTER, owner, name, type.parameterType(0)));</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1653</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">case</span> REF_invokeVirtual    -&#62; Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.VIRTUAL, owner, name, type));</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1654</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">case</span> REF_invokeStatic     -&#62; isInterface ?</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1655</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                                          Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, owner, name, type)) :</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1656</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                                          Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, owner, name, type));</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1657</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">case</span> REF_invokeSpecial    -&#62; isInterface ?</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1658</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                                          Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_SPECIAL, owner, name, type)) :</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1659</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                                          Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.SPECIAL, owner, name, type));</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1660</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">case</span> REF_invokeInterface  -&#62; Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, owner, name, type));</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1661</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">case</span> REF_newInvokeSpecial -&#62; Optional.of(MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.CONSTRUCTOR, owner, name, type));</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1662</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">default</span> -&#62; Optional.empty();</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1663</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        };</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1664</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1665</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1666</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1667</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Returns a string representation of the method handle,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1668</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * starting with the string {@code "MethodHandle"} and</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1669</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * ending with the string representation of the method handle's type.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1670</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * In other words, this method returns a string equal to the value of:</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1671</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * {@snippet lang="java" :</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1672</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * "MethodHandle" + type().toString()</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1673</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * }</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1674</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * &#60;p&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1675</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * (&#60;em&#62;Note:&#60;/em&#62;  Future releases of this API may add further information</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1676</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * to the string representation.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1677</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Therefore, the present syntax should not be parsed by applications.)</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1678</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1679</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * @return a string representation of the method handle</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1680</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1681</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    @Override</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1682</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">public</span> String toString() {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1683<a name="src_1683"></a></td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (DEBUG_METHOD_HANDLE_NAMES)  <span Class="keyword">return</span> <span Class="string">"MethodHandle"</span>+debugString();</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1684</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/2&nbsp;Branch:&nbsp;0/2&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> standardString();</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1685</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1686</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    String standardString() {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1687<a name="src_1687"></a></td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> <span Class="string">"MethodHandle"</span>+type;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1688</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1689</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">* Return a string with a several lines describing the method handle structure.</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1690</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *  This string would be suitable for display in an IDE debugger.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1691</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1692</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    String debugString() {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1693<a name="src_1693"></a></td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> type+<span Class="string">" : "</span>+internalForm()+internalProperties();</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1694</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1695</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1696</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">//// Implementation methods.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1697</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">//// Sub-classes can override these default implementations.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1698</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">//// All these methods assume arguments are already validated.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1699</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1700</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">// Other transforms to do:  convert, explicitCast, permute, drop, filter, fold, GWT, catch</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1701</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1702</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    BoundMethodHandle bindArgumentL(<span Class="keyword">int</span> pos, Object value) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1703<a name="src_1703"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> rebind().bindArgumentL(pos, value);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1704</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1705</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1706</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1707</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    MethodHandle setVarargs(MemberName member) <span Class="keyword">throws</span> IllegalAccessException {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1708<a name="src_1708"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (!member.isVarargs())  <span Class="keyword">return</span> <span Class="keyword">this</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1709</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">try</span> {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1710</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">return</span> <span Class="keyword">this</span>.withVarargs(<span Class="keyword">true</span>);</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1711</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        } <span Class="keyword">catch</span> (IllegalArgumentException ex) {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1712</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">throw</span> member.makeAccessException(<span Class="string">"cannot make variable arity"</span>, <span Class="keyword">null</span>);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1713</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1714</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1715</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1716</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1717</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    MethodHandle viewAsType(MethodType newType, <span Class="keyword">boolean</span> strict) {</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1718</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="comment">// No actual conversions, just a new view of the same method.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1719</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="comment">// Overridden in DMH, which has special rules</span></pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1720<a name="src_1720"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">assert</span>(viewAsTypeChecks(newType, strict));</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1721</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;2/3&nbsp;Branch:&nbsp;3/4&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> copyWith(newType, form);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1722</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1723</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1724</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1725</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">boolean</span> viewAsTypeChecks(MethodType newType, <span Class="keyword">boolean</span> strict) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1726<a name="src_1726"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (strict) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1727</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">assert</span>(type().isViewableAs(newType, <span Class="keyword">true</span>))</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1728</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                : Arrays.asList(<span Class="keyword">this</span>, newType);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1729</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        } <span Class="keyword">else</span> {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1730</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">assert</span>(type().basicType().isViewableAs(newType.basicType(), <span Class="keyword">true</span>))</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1731</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                : Arrays.asList(<span Class="keyword">this</span>, newType);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1732</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1733</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;2/3&nbsp;Branch:&nbsp;2/6&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> <span Class="keyword">true</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1734</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1735</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1736</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">// Decoding</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1737</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1738</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1739</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    LambdaForm internalForm() {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1740<a name="src_1740"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> form;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1741</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1742</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1743</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1744</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    MemberName internalMemberName() {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1745<a name="src_1745"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> <span Class="keyword">null</span>;  <span Class="comment">// DMH returns DMH.member</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1746</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1747</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1748</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1749</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    Class&#60;?&#62; internalCallerClass() {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1750<a name="src_1750"></a></td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> <span Class="keyword">null</span>;  <span Class="comment">// caller-bound MH for @CallerSensitive method returns caller</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1751</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1752</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1753</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1754</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    MethodHandleImpl.Intrinsic intrinsicName() {</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1755</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="comment">// no special intrinsic meaning to most MHs</span></pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1756<a name="src_1756"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> MethodHandleImpl.Intrinsic.NONE;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1757</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1758</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1759</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1760</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    Object intrinsicData() {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1761<a name="src_1761"></a></td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> <span Class="keyword">null</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1762</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1763</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1764</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1765</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    MethodHandle withInternalMemberName(MemberName member, <span Class="keyword">boolean</span> isInvokeSpecial) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1766<a name="src_1766"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (member != <span Class="keyword">null</span>) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1767</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">return</span> MethodHandleImpl.makeWrappedMember(<span Class="keyword">this</span>, member, isInvokeSpecial);</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1768</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        } <span Class="keyword">else</span> <span Class="keyword">if</span> (internalMemberName() == <span Class="keyword">null</span>) {</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1769</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="comment">// The required internalMemberName is null, and this MH (like most) doesn't have one.</span></pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1770</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">return</span> <span Class="keyword">this</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1771</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        } <span Class="keyword">else</span> {</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1772</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="comment">// The following case is rare. Mask the internalMemberName by wrapping the MH in a BMH.</span></pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1773</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            MethodHandle result = rebind();</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1774</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">assert</span>(result.internalMemberName() == <span Class="keyword">null</span>);</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1775</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/3&nbsp;Branch:&nbsp;0/4&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">return</span> result;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1776</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1777</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1778</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1779</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1780</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">boolean</span> isInvokeSpecial() {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1781<a name="src_1781"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> <span Class="keyword">false</span>;  <span Class="comment">// DMH.Special returns true</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1782</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1783</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1784</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1785</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">boolean</span> isCrackable() {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1786<a name="src_1786"></a></td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> <span Class="keyword">false</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1787</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1788</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1789</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1790</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    Object internalValues() {</pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1791<a name="src_1791"></a></td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> <span Class="keyword">null</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1792</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1793</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1794</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1795</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    Object internalProperties() {</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1796</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="comment">// Override to something to follow this.form, like "\n&#38; FOO=bar"</span></pre></td>
 </tr>
 <tr>
 <td class="numLineUnCover">&nbsp;1797<a name="src_1797"></a></td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">return</span> <span Class="string">""</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1798</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1799</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1800</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">//// Method handle implementation methods.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1801</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">//// Sub-classes can override these default implementations.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1802</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">//// All these methods assume arguments are already validated.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1803</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1804</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1805</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">abstract</span> MethodHandle copyWith(MethodType mt, LambdaForm lf);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1806</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1807</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">* Require this method handle to be a BMH, or else replace it with a "wrapper" BMH.</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1808</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *  Many transforms are implemented only for BMHs.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1809</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     *  @return a behaviorally equivalent BMH</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1810</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1811</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">abstract</span> BoundMethodHandle rebind();</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1812</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1813</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment"> non-public */</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1814</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">void</span> maybeCustomize() {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1815<a name="src_1815"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (form.customized == <span Class="keyword">null</span>) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1816</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">byte</span> count = customizationCount;</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1817</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">if</span> (count &#62;= CUSTOMIZE_THRESHOLD) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1818</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                customize();</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1819</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            } <span Class="keyword">else</span> {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1820</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                customizationCount = (<span Class="keyword">byte</span>) (count + 1);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1821</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1822</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1823</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1824</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1825</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">* Craft a LambdaForm customized for this particular MethodHandle. */</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1826</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1827</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">void</span> customize() {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1828<a name="src_1828"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;2/2&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        updateForm(<span Class="keyword">new</span> Function&#60;&#62;() {</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1829</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                <span Class="keyword">public</span> LambdaForm apply(LambdaForm oldForm) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1830<a name="src_1830"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                    <span Class="keyword">return</span> oldForm.customize(MethodHandle.<span Class="keyword">this</span>);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1831</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1832</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            });</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1833</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1834</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1835</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">private</span> <span Class="keyword">volatile</span> <span Class="keyword">boolean</span> updateInProgress; <span Class="comment">// = false;</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1836</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1837</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">*</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1838</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Replace the old lambda form of this method handle with a new one.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1839</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * The new one must be functionally equivalent to the old one.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1840</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Threads may continue running the old form indefinitely,</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1841</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * but it is likely that the new one will be preferred for new executions.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1842</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     * Use with discretion.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1843</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;<span Class="comment">     */</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1844</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="comment">/*<span Class="comment">non-public*/</span></span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1845</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">void</span> updateForm(Function&#60;LambdaForm, LambdaForm&#62; updater) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1846<a name="src_1846"></a></td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        <span Class="keyword">if</span> (UNSAFE.compareAndSetBoolean(<span Class="keyword">this</span>, UPDATE_OFFSET, <span Class="keyword">false</span>, <span Class="keyword">true</span>)) { <span Class="comment">// updateInProgress = true</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1847</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="comment">// Only 1 thread wins the race and updates MH.form field.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1848</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="keyword">try</span> {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1849</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                LambdaForm oldForm = form;</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1850</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                LambdaForm newForm = updater.apply(oldForm);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1851</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                <span Class="keyword">if</span> (oldForm != newForm) {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1852</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                    <span Class="keyword">assert</span> (newForm.customized == <span Class="keyword">null</span> || newForm.customized == <span Class="keyword">this</span>);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1853</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;Branch:&nbsp;3/3&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                    newForm.prepare(); <span Class="comment">// as in MethodHandle.&#60;init&#62;</span></pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1854</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                    UNSAFE.putReference(<span Class="keyword">this</span>, FORM_OFFSET, newForm);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1855</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                    UNSAFE.fullFence();</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1856</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1857</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            } <span Class="keyword">finally</span> {</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1858</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;1/2&nbsp;Branch:&nbsp;0/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;                updateInProgress = <span Class="keyword">false</span>;</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1859</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1860</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        } <span Class="keyword">else</span> {</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1861</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;            <span Class="comment">// Update got lost due to concurrent update. But callers don't care.</span></pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1862</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;        }</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1863</td>
 <td class="nbHitsUncovered">&nbsp;Block:&nbsp;3/4&nbsp;Branch:&nbsp;2/4&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    }</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1864</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1865</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;1/1&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">private</span> <span Class="keyword">static</span> <span Class="keyword">final</span> <span Class="keyword">long</span>   FORM_OFFSET = UNSAFE.objectFieldOffset(MethodHandle.<span Class="keyword">class</span>, <span Class="string">"form"</span>);</pre></td>
 </tr>
 <tr>
 <td class="numLineCover">&nbsp;1866</td>
 <td class="nbHitsCovered">&nbsp;Block:&nbsp;2/2&nbsp;Branch:&nbsp;2/2&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;    <span Class="keyword">private</span> <span Class="keyword">static</span> <span Class="keyword">final</span> <span Class="keyword">long</span> UPDATE_OFFSET = UNSAFE.objectFieldOffset(MethodHandle.<span Class="keyword">class</span>, <span Class="string">"updateInProgress"</span>);</pre></td>
 </tr>
 <tr>
 <td class="numLine">&nbsp;1867</td>
 <td class="nbHits">&nbsp;</td>
 <td class="src"><pre class="src">&nbsp;}</pre></td>
 </tr>
 </table>
<p>
<br><table cellpadding="0" cellspacing="0" class="report">  <tr class="report">    <td class="reportText"><span class="text">    Report generated 8/4/22, 3:35 PM    </span></td>  </tr></table>
</body>
</html>
